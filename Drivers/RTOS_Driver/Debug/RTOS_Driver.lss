
RTOS_Driver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000d86  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          0000001a  00800060  00800060  00000dfa  2**0
                  ALLOC
  2 .stab         0000132c  00000000  00000000  00000dfc  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000cff  00000000  00000000  00002128  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  28:	0c 94 78 05 	jmp	0xaf0	; 0xaf0 <__vector_10>
  2c:	0c 94 2f 05 	jmp	0xa5e	; 0xa5e <__vector_11>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	aa 37       	cpi	r26, 0x7A	; 122
  6c:	b1 07       	cpc	r27, r17
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 48 06 	call	0xc90	; 0xc90 <main>
  74:	0c 94 c1 06 	jmp	0xd82	; 0xd82 <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <MDIO_voidInit>:
#include"../include/MCAL/DIO/DIO_interface.h"
#include"../include/MCAL/DIO/DIO_private.h"
#include"../include/MCAL/DIO/DIO_configuration.h"

void MDIO_voidInit (void)
{
  7c:	df 93       	push	r29
  7e:	cf 93       	push	r28
  80:	cd b7       	in	r28, 0x3d	; 61
  82:	de b7       	in	r29, 0x3e	; 62
	DDRA_REG = CONC_BIT(PORTA_PIN7_DIRECTION, PORTA_PIN6_DIRECTION, PORTA_PIN5_DIRECTION, PORTA_PIN4_DIRECTION,
  84:	ea e3       	ldi	r30, 0x3A	; 58
  86:	f0 e0       	ldi	r31, 0x00	; 0
  88:	8f ef       	ldi	r24, 0xFF	; 255
  8a:	80 83       	st	Z, r24
						PORTA_PIN3_DIRECTION, PORTA_PIN2_DIRECTION, PORTA_PIN1_DIRECTION, PORTA_PIN0_DIRECTION);

	DDRB_REG = CONC_BIT(PORTB_PIN7_DIRECTION, PORTB_PIN6_DIRECTION, PORTB_PIN5_DIRECTION, PORTB_PIN4_DIRECTION,
  8c:	e7 e3       	ldi	r30, 0x37	; 55
  8e:	f0 e0       	ldi	r31, 0x00	; 0
  90:	8f ef       	ldi	r24, 0xFF	; 255
  92:	80 83       	st	Z, r24
						PORTB_PIN3_DIRECTION, PORTB_PIN2_DIRECTION, PORTB_PIN1_DIRECTION, PORTB_PIN0_DIRECTION);

	DDRC_REG = CONC_BIT(PORTC_PIN7_DIRECTION, PORTC_PIN6_DIRECTION, PORTC_PIN5_DIRECTION, PORTC_PIN4_DIRECTION,
  94:	e4 e3       	ldi	r30, 0x34	; 52
  96:	f0 e0       	ldi	r31, 0x00	; 0
  98:	8f ef       	ldi	r24, 0xFF	; 255
  9a:	80 83       	st	Z, r24
						PORTC_PIN3_DIRECTION, PORTC_PIN2_DIRECTION, PORTC_PIN1_DIRECTION, PORTC_PIN0_DIRECTION);

	DDRD_REG = CONC_BIT(PORTD_PIN7_DIRECTION, PORTD_PIN6_DIRECTION, PORTD_PIN5_DIRECTION, PORTD_PIN4_DIRECTION,
  9c:	e1 e3       	ldi	r30, 0x31	; 49
  9e:	f0 e0       	ldi	r31, 0x00	; 0
  a0:	8f ef       	ldi	r24, 0xFF	; 255
  a2:	80 83       	st	Z, r24
						PORTD_PIN3_DIRECTION, PORTD_PIN2_DIRECTION, PORTD_PIN1_DIRECTION, PORTD_PIN0_DIRECTION);

	PORTA_REG = CONC_BIT(PORTA_PIN7_VALUE, PORTA_PIN6_VALUE, PORTA_PIN5_VALUE, PORTA_PIN4_VALUE,
  a4:	eb e3       	ldi	r30, 0x3B	; 59
  a6:	f0 e0       	ldi	r31, 0x00	; 0
  a8:	10 82       	st	Z, r1
						 PORTA_PIN3_VALUE, PORTA_PIN2_VALUE, PORTA_PIN1_VALUE, PORTA_PIN0_VALUE);

	PORTB_REG = CONC_BIT(PORTB_PIN7_VALUE, PORTB_PIN6_VALUE, PORTB_PIN5_VALUE, PORTB_PIN4_VALUE,
  aa:	e8 e3       	ldi	r30, 0x38	; 56
  ac:	f0 e0       	ldi	r31, 0x00	; 0
  ae:	10 82       	st	Z, r1
						 PORTB_PIN3_VALUE, PORTB_PIN2_VALUE, PORTB_PIN1_VALUE, PORTB_PIN0_VALUE);

	PORTC_REG = CONC_BIT(PORTC_PIN7_VALUE, PORTC_PIN6_VALUE, PORTC_PIN5_VALUE, PORTC_PIN4_VALUE,
  b0:	e5 e3       	ldi	r30, 0x35	; 53
  b2:	f0 e0       	ldi	r31, 0x00	; 0
  b4:	10 82       	st	Z, r1
		   				 PORTC_PIN3_VALUE, PORTC_PIN2_VALUE, PORTC_PIN1_VALUE, PORTC_PIN0_VALUE);

	PORTD_REG = CONC_BIT(PORTD_PIN7_VALUE, PORTD_PIN6_VALUE, PORTD_PIN5_VALUE, PORTD_PIN4_VALUE,
  b6:	e2 e3       	ldi	r30, 0x32	; 50
  b8:	f0 e0       	ldi	r31, 0x00	; 0
  ba:	10 82       	st	Z, r1
						 PORTD_PIN3_VALUE, PORTD_PIN2_VALUE, PORTD_PIN1_VALUE, PORTD_PIN0_VALUE);

}
  bc:	cf 91       	pop	r28
  be:	df 91       	pop	r29
  c0:	08 95       	ret

000000c2 <MDIO_voidSetPinDirection>:
// PORT ID :- POTRTA - PORTB - PORTC - PORTD
// PIN ID :- PIN0 ... PIN7
// PIN DIRECTION:- PIN_INPUT - PIN_OUTPUT
void MDIO_voidSetPinDirection (u8 A_u8PortId, u8 A_u8PinId, u8 A_u8Direction)
{
  c2:	df 93       	push	r29
  c4:	cf 93       	push	r28
  c6:	cd b7       	in	r28, 0x3d	; 61
  c8:	de b7       	in	r29, 0x3e	; 62
  ca:	2d 97       	sbiw	r28, 0x0d	; 13
  cc:	0f b6       	in	r0, 0x3f	; 63
  ce:	f8 94       	cli
  d0:	de bf       	out	0x3e, r29	; 62
  d2:	0f be       	out	0x3f, r0	; 63
  d4:	cd bf       	out	0x3d, r28	; 61
  d6:	89 83       	std	Y+1, r24	; 0x01
  d8:	6a 83       	std	Y+2, r22	; 0x02
  da:	4b 83       	std	Y+3, r20	; 0x03
	switch(A_u8PortId)
  dc:	89 81       	ldd	r24, Y+1	; 0x01
  de:	28 2f       	mov	r18, r24
  e0:	30 e0       	ldi	r19, 0x00	; 0
  e2:	3d 87       	std	Y+13, r19	; 0x0d
  e4:	2c 87       	std	Y+12, r18	; 0x0c
  e6:	8c 85       	ldd	r24, Y+12	; 0x0c
  e8:	9d 85       	ldd	r25, Y+13	; 0x0d
  ea:	81 30       	cpi	r24, 0x01	; 1
  ec:	91 05       	cpc	r25, r1
  ee:	09 f4       	brne	.+2      	; 0xf2 <MDIO_voidSetPinDirection+0x30>
  f0:	4f c0       	rjmp	.+158    	; 0x190 <MDIO_voidSetPinDirection+0xce>
  f2:	2c 85       	ldd	r18, Y+12	; 0x0c
  f4:	3d 85       	ldd	r19, Y+13	; 0x0d
  f6:	22 30       	cpi	r18, 0x02	; 2
  f8:	31 05       	cpc	r19, r1
  fa:	2c f4       	brge	.+10     	; 0x106 <MDIO_voidSetPinDirection+0x44>
  fc:	8c 85       	ldd	r24, Y+12	; 0x0c
  fe:	9d 85       	ldd	r25, Y+13	; 0x0d
 100:	00 97       	sbiw	r24, 0x00	; 0
 102:	71 f0       	breq	.+28     	; 0x120 <MDIO_voidSetPinDirection+0x5e>
 104:	eb c0       	rjmp	.+470    	; 0x2dc <MDIO_voidSetPinDirection+0x21a>
 106:	2c 85       	ldd	r18, Y+12	; 0x0c
 108:	3d 85       	ldd	r19, Y+13	; 0x0d
 10a:	22 30       	cpi	r18, 0x02	; 2
 10c:	31 05       	cpc	r19, r1
 10e:	09 f4       	brne	.+2      	; 0x112 <MDIO_voidSetPinDirection+0x50>
 110:	77 c0       	rjmp	.+238    	; 0x200 <MDIO_voidSetPinDirection+0x13e>
 112:	8c 85       	ldd	r24, Y+12	; 0x0c
 114:	9d 85       	ldd	r25, Y+13	; 0x0d
 116:	83 30       	cpi	r24, 0x03	; 3
 118:	91 05       	cpc	r25, r1
 11a:	09 f4       	brne	.+2      	; 0x11e <MDIO_voidSetPinDirection+0x5c>
 11c:	a9 c0       	rjmp	.+338    	; 0x270 <MDIO_voidSetPinDirection+0x1ae>
 11e:	de c0       	rjmp	.+444    	; 0x2dc <MDIO_voidSetPinDirection+0x21a>
	{
	case PORTA:
		switch(A_u8Direction)
 120:	8b 81       	ldd	r24, Y+3	; 0x03
 122:	28 2f       	mov	r18, r24
 124:	30 e0       	ldi	r19, 0x00	; 0
 126:	3b 87       	std	Y+11, r19	; 0x0b
 128:	2a 87       	std	Y+10, r18	; 0x0a
 12a:	8a 85       	ldd	r24, Y+10	; 0x0a
 12c:	9b 85       	ldd	r25, Y+11	; 0x0b
 12e:	00 97       	sbiw	r24, 0x00	; 0
 130:	d1 f0       	breq	.+52     	; 0x166 <MDIO_voidSetPinDirection+0xa4>
 132:	2a 85       	ldd	r18, Y+10	; 0x0a
 134:	3b 85       	ldd	r19, Y+11	; 0x0b
 136:	21 30       	cpi	r18, 0x01	; 1
 138:	31 05       	cpc	r19, r1
 13a:	09 f0       	breq	.+2      	; 0x13e <MDIO_voidSetPinDirection+0x7c>
 13c:	cf c0       	rjmp	.+414    	; 0x2dc <MDIO_voidSetPinDirection+0x21a>
		{
		case PIN_OUTPUT: SET_BIT(DDRA_REG,A_u8PinId);
 13e:	aa e3       	ldi	r26, 0x3A	; 58
 140:	b0 e0       	ldi	r27, 0x00	; 0
 142:	ea e3       	ldi	r30, 0x3A	; 58
 144:	f0 e0       	ldi	r31, 0x00	; 0
 146:	80 81       	ld	r24, Z
 148:	48 2f       	mov	r20, r24
 14a:	8a 81       	ldd	r24, Y+2	; 0x02
 14c:	28 2f       	mov	r18, r24
 14e:	30 e0       	ldi	r19, 0x00	; 0
 150:	81 e0       	ldi	r24, 0x01	; 1
 152:	90 e0       	ldi	r25, 0x00	; 0
 154:	02 2e       	mov	r0, r18
 156:	02 c0       	rjmp	.+4      	; 0x15c <MDIO_voidSetPinDirection+0x9a>
 158:	88 0f       	add	r24, r24
 15a:	99 1f       	adc	r25, r25
 15c:	0a 94       	dec	r0
 15e:	e2 f7       	brpl	.-8      	; 0x158 <MDIO_voidSetPinDirection+0x96>
 160:	84 2b       	or	r24, r20
 162:	8c 93       	st	X, r24
 164:	bb c0       	rjmp	.+374    	; 0x2dc <MDIO_voidSetPinDirection+0x21a>
						 break;
		case PIN_INPUT : CLR_BIT(DDRA_REG,A_u8PinId);
 166:	aa e3       	ldi	r26, 0x3A	; 58
 168:	b0 e0       	ldi	r27, 0x00	; 0
 16a:	ea e3       	ldi	r30, 0x3A	; 58
 16c:	f0 e0       	ldi	r31, 0x00	; 0
 16e:	80 81       	ld	r24, Z
 170:	48 2f       	mov	r20, r24
 172:	8a 81       	ldd	r24, Y+2	; 0x02
 174:	28 2f       	mov	r18, r24
 176:	30 e0       	ldi	r19, 0x00	; 0
 178:	81 e0       	ldi	r24, 0x01	; 1
 17a:	90 e0       	ldi	r25, 0x00	; 0
 17c:	02 2e       	mov	r0, r18
 17e:	02 c0       	rjmp	.+4      	; 0x184 <MDIO_voidSetPinDirection+0xc2>
 180:	88 0f       	add	r24, r24
 182:	99 1f       	adc	r25, r25
 184:	0a 94       	dec	r0
 186:	e2 f7       	brpl	.-8      	; 0x180 <MDIO_voidSetPinDirection+0xbe>
 188:	80 95       	com	r24
 18a:	84 23       	and	r24, r20
 18c:	8c 93       	st	X, r24
 18e:	a6 c0       	rjmp	.+332    	; 0x2dc <MDIO_voidSetPinDirection+0x21a>
		default:
				 break;
		}
		break;
	case PORTB:
		switch(A_u8Direction)
 190:	8b 81       	ldd	r24, Y+3	; 0x03
 192:	28 2f       	mov	r18, r24
 194:	30 e0       	ldi	r19, 0x00	; 0
 196:	39 87       	std	Y+9, r19	; 0x09
 198:	28 87       	std	Y+8, r18	; 0x08
 19a:	88 85       	ldd	r24, Y+8	; 0x08
 19c:	99 85       	ldd	r25, Y+9	; 0x09
 19e:	00 97       	sbiw	r24, 0x00	; 0
 1a0:	d1 f0       	breq	.+52     	; 0x1d6 <MDIO_voidSetPinDirection+0x114>
 1a2:	28 85       	ldd	r18, Y+8	; 0x08
 1a4:	39 85       	ldd	r19, Y+9	; 0x09
 1a6:	21 30       	cpi	r18, 0x01	; 1
 1a8:	31 05       	cpc	r19, r1
 1aa:	09 f0       	breq	.+2      	; 0x1ae <MDIO_voidSetPinDirection+0xec>
 1ac:	97 c0       	rjmp	.+302    	; 0x2dc <MDIO_voidSetPinDirection+0x21a>
		{
		case PIN_OUTPUT: SET_BIT(DDRB_REG,A_u8PinId);
 1ae:	a7 e3       	ldi	r26, 0x37	; 55
 1b0:	b0 e0       	ldi	r27, 0x00	; 0
 1b2:	e7 e3       	ldi	r30, 0x37	; 55
 1b4:	f0 e0       	ldi	r31, 0x00	; 0
 1b6:	80 81       	ld	r24, Z
 1b8:	48 2f       	mov	r20, r24
 1ba:	8a 81       	ldd	r24, Y+2	; 0x02
 1bc:	28 2f       	mov	r18, r24
 1be:	30 e0       	ldi	r19, 0x00	; 0
 1c0:	81 e0       	ldi	r24, 0x01	; 1
 1c2:	90 e0       	ldi	r25, 0x00	; 0
 1c4:	02 2e       	mov	r0, r18
 1c6:	02 c0       	rjmp	.+4      	; 0x1cc <MDIO_voidSetPinDirection+0x10a>
 1c8:	88 0f       	add	r24, r24
 1ca:	99 1f       	adc	r25, r25
 1cc:	0a 94       	dec	r0
 1ce:	e2 f7       	brpl	.-8      	; 0x1c8 <MDIO_voidSetPinDirection+0x106>
 1d0:	84 2b       	or	r24, r20
 1d2:	8c 93       	st	X, r24
 1d4:	83 c0       	rjmp	.+262    	; 0x2dc <MDIO_voidSetPinDirection+0x21a>
						 break;
		case PIN_INPUT : CLR_BIT(DDRB_REG,A_u8PinId);
 1d6:	a7 e3       	ldi	r26, 0x37	; 55
 1d8:	b0 e0       	ldi	r27, 0x00	; 0
 1da:	e7 e3       	ldi	r30, 0x37	; 55
 1dc:	f0 e0       	ldi	r31, 0x00	; 0
 1de:	80 81       	ld	r24, Z
 1e0:	48 2f       	mov	r20, r24
 1e2:	8a 81       	ldd	r24, Y+2	; 0x02
 1e4:	28 2f       	mov	r18, r24
 1e6:	30 e0       	ldi	r19, 0x00	; 0
 1e8:	81 e0       	ldi	r24, 0x01	; 1
 1ea:	90 e0       	ldi	r25, 0x00	; 0
 1ec:	02 2e       	mov	r0, r18
 1ee:	02 c0       	rjmp	.+4      	; 0x1f4 <MDIO_voidSetPinDirection+0x132>
 1f0:	88 0f       	add	r24, r24
 1f2:	99 1f       	adc	r25, r25
 1f4:	0a 94       	dec	r0
 1f6:	e2 f7       	brpl	.-8      	; 0x1f0 <MDIO_voidSetPinDirection+0x12e>
 1f8:	80 95       	com	r24
 1fa:	84 23       	and	r24, r20
 1fc:	8c 93       	st	X, r24
 1fe:	6e c0       	rjmp	.+220    	; 0x2dc <MDIO_voidSetPinDirection+0x21a>
		default:
				break;
		}
		break;
	case PORTC:
		switch(A_u8Direction)
 200:	8b 81       	ldd	r24, Y+3	; 0x03
 202:	28 2f       	mov	r18, r24
 204:	30 e0       	ldi	r19, 0x00	; 0
 206:	3f 83       	std	Y+7, r19	; 0x07
 208:	2e 83       	std	Y+6, r18	; 0x06
 20a:	8e 81       	ldd	r24, Y+6	; 0x06
 20c:	9f 81       	ldd	r25, Y+7	; 0x07
 20e:	00 97       	sbiw	r24, 0x00	; 0
 210:	d1 f0       	breq	.+52     	; 0x246 <MDIO_voidSetPinDirection+0x184>
 212:	2e 81       	ldd	r18, Y+6	; 0x06
 214:	3f 81       	ldd	r19, Y+7	; 0x07
 216:	21 30       	cpi	r18, 0x01	; 1
 218:	31 05       	cpc	r19, r1
 21a:	09 f0       	breq	.+2      	; 0x21e <MDIO_voidSetPinDirection+0x15c>
 21c:	5f c0       	rjmp	.+190    	; 0x2dc <MDIO_voidSetPinDirection+0x21a>
		{
		case PIN_OUTPUT: SET_BIT(DDRC_REG,A_u8PinId);
 21e:	a4 e3       	ldi	r26, 0x34	; 52
 220:	b0 e0       	ldi	r27, 0x00	; 0
 222:	e4 e3       	ldi	r30, 0x34	; 52
 224:	f0 e0       	ldi	r31, 0x00	; 0
 226:	80 81       	ld	r24, Z
 228:	48 2f       	mov	r20, r24
 22a:	8a 81       	ldd	r24, Y+2	; 0x02
 22c:	28 2f       	mov	r18, r24
 22e:	30 e0       	ldi	r19, 0x00	; 0
 230:	81 e0       	ldi	r24, 0x01	; 1
 232:	90 e0       	ldi	r25, 0x00	; 0
 234:	02 2e       	mov	r0, r18
 236:	02 c0       	rjmp	.+4      	; 0x23c <MDIO_voidSetPinDirection+0x17a>
 238:	88 0f       	add	r24, r24
 23a:	99 1f       	adc	r25, r25
 23c:	0a 94       	dec	r0
 23e:	e2 f7       	brpl	.-8      	; 0x238 <MDIO_voidSetPinDirection+0x176>
 240:	84 2b       	or	r24, r20
 242:	8c 93       	st	X, r24
 244:	4b c0       	rjmp	.+150    	; 0x2dc <MDIO_voidSetPinDirection+0x21a>
						 break;
		case PIN_INPUT : CLR_BIT(DDRC_REG,A_u8PinId);
 246:	a4 e3       	ldi	r26, 0x34	; 52
 248:	b0 e0       	ldi	r27, 0x00	; 0
 24a:	e4 e3       	ldi	r30, 0x34	; 52
 24c:	f0 e0       	ldi	r31, 0x00	; 0
 24e:	80 81       	ld	r24, Z
 250:	48 2f       	mov	r20, r24
 252:	8a 81       	ldd	r24, Y+2	; 0x02
 254:	28 2f       	mov	r18, r24
 256:	30 e0       	ldi	r19, 0x00	; 0
 258:	81 e0       	ldi	r24, 0x01	; 1
 25a:	90 e0       	ldi	r25, 0x00	; 0
 25c:	02 2e       	mov	r0, r18
 25e:	02 c0       	rjmp	.+4      	; 0x264 <MDIO_voidSetPinDirection+0x1a2>
 260:	88 0f       	add	r24, r24
 262:	99 1f       	adc	r25, r25
 264:	0a 94       	dec	r0
 266:	e2 f7       	brpl	.-8      	; 0x260 <MDIO_voidSetPinDirection+0x19e>
 268:	80 95       	com	r24
 26a:	84 23       	and	r24, r20
 26c:	8c 93       	st	X, r24
 26e:	36 c0       	rjmp	.+108    	; 0x2dc <MDIO_voidSetPinDirection+0x21a>
		default:
				break;
		}
		break;
	case PORTD:
		switch(A_u8Direction)
 270:	8b 81       	ldd	r24, Y+3	; 0x03
 272:	28 2f       	mov	r18, r24
 274:	30 e0       	ldi	r19, 0x00	; 0
 276:	3d 83       	std	Y+5, r19	; 0x05
 278:	2c 83       	std	Y+4, r18	; 0x04
 27a:	8c 81       	ldd	r24, Y+4	; 0x04
 27c:	9d 81       	ldd	r25, Y+5	; 0x05
 27e:	00 97       	sbiw	r24, 0x00	; 0
 280:	c9 f0       	breq	.+50     	; 0x2b4 <MDIO_voidSetPinDirection+0x1f2>
 282:	2c 81       	ldd	r18, Y+4	; 0x04
 284:	3d 81       	ldd	r19, Y+5	; 0x05
 286:	21 30       	cpi	r18, 0x01	; 1
 288:	31 05       	cpc	r19, r1
 28a:	41 f5       	brne	.+80     	; 0x2dc <MDIO_voidSetPinDirection+0x21a>
		{
		case PIN_OUTPUT: SET_BIT(DDRD_REG,A_u8PinId);
 28c:	a1 e3       	ldi	r26, 0x31	; 49
 28e:	b0 e0       	ldi	r27, 0x00	; 0
 290:	e1 e3       	ldi	r30, 0x31	; 49
 292:	f0 e0       	ldi	r31, 0x00	; 0
 294:	80 81       	ld	r24, Z
 296:	48 2f       	mov	r20, r24
 298:	8a 81       	ldd	r24, Y+2	; 0x02
 29a:	28 2f       	mov	r18, r24
 29c:	30 e0       	ldi	r19, 0x00	; 0
 29e:	81 e0       	ldi	r24, 0x01	; 1
 2a0:	90 e0       	ldi	r25, 0x00	; 0
 2a2:	02 2e       	mov	r0, r18
 2a4:	02 c0       	rjmp	.+4      	; 0x2aa <MDIO_voidSetPinDirection+0x1e8>
 2a6:	88 0f       	add	r24, r24
 2a8:	99 1f       	adc	r25, r25
 2aa:	0a 94       	dec	r0
 2ac:	e2 f7       	brpl	.-8      	; 0x2a6 <MDIO_voidSetPinDirection+0x1e4>
 2ae:	84 2b       	or	r24, r20
 2b0:	8c 93       	st	X, r24
 2b2:	14 c0       	rjmp	.+40     	; 0x2dc <MDIO_voidSetPinDirection+0x21a>
						 break;
		case PIN_INPUT : CLR_BIT(DDRD_REG,A_u8PinId);
 2b4:	a1 e3       	ldi	r26, 0x31	; 49
 2b6:	b0 e0       	ldi	r27, 0x00	; 0
 2b8:	e1 e3       	ldi	r30, 0x31	; 49
 2ba:	f0 e0       	ldi	r31, 0x00	; 0
 2bc:	80 81       	ld	r24, Z
 2be:	48 2f       	mov	r20, r24
 2c0:	8a 81       	ldd	r24, Y+2	; 0x02
 2c2:	28 2f       	mov	r18, r24
 2c4:	30 e0       	ldi	r19, 0x00	; 0
 2c6:	81 e0       	ldi	r24, 0x01	; 1
 2c8:	90 e0       	ldi	r25, 0x00	; 0
 2ca:	02 2e       	mov	r0, r18
 2cc:	02 c0       	rjmp	.+4      	; 0x2d2 <MDIO_voidSetPinDirection+0x210>
 2ce:	88 0f       	add	r24, r24
 2d0:	99 1f       	adc	r25, r25
 2d2:	0a 94       	dec	r0
 2d4:	e2 f7       	brpl	.-8      	; 0x2ce <MDIO_voidSetPinDirection+0x20c>
 2d6:	80 95       	com	r24
 2d8:	84 23       	and	r24, r20
 2da:	8c 93       	st	X, r24
		}
		break;
	default:
		break;
	}
}
 2dc:	2d 96       	adiw	r28, 0x0d	; 13
 2de:	0f b6       	in	r0, 0x3f	; 63
 2e0:	f8 94       	cli
 2e2:	de bf       	out	0x3e, r29	; 62
 2e4:	0f be       	out	0x3f, r0	; 63
 2e6:	cd bf       	out	0x3d, r28	; 61
 2e8:	cf 91       	pop	r28
 2ea:	df 91       	pop	r29
 2ec:	08 95       	ret

000002ee <MDIO_voidSetPinValue>:
// PORT ID :- POTRTA - PORTB - PORTC - PORTD
// PIN ID :- PIN0 ... PIN7
// PIN VALUE:- PIN_LOW - PIN_HIGH
void MDIO_voidSetPinValue (u8 A_u8PortId, u8 A_u8PinId, u8 A_u8Value)
{
 2ee:	df 93       	push	r29
 2f0:	cf 93       	push	r28
 2f2:	cd b7       	in	r28, 0x3d	; 61
 2f4:	de b7       	in	r29, 0x3e	; 62
 2f6:	2d 97       	sbiw	r28, 0x0d	; 13
 2f8:	0f b6       	in	r0, 0x3f	; 63
 2fa:	f8 94       	cli
 2fc:	de bf       	out	0x3e, r29	; 62
 2fe:	0f be       	out	0x3f, r0	; 63
 300:	cd bf       	out	0x3d, r28	; 61
 302:	89 83       	std	Y+1, r24	; 0x01
 304:	6a 83       	std	Y+2, r22	; 0x02
 306:	4b 83       	std	Y+3, r20	; 0x03
	switch(A_u8PortId)
 308:	89 81       	ldd	r24, Y+1	; 0x01
 30a:	28 2f       	mov	r18, r24
 30c:	30 e0       	ldi	r19, 0x00	; 0
 30e:	3d 87       	std	Y+13, r19	; 0x0d
 310:	2c 87       	std	Y+12, r18	; 0x0c
 312:	8c 85       	ldd	r24, Y+12	; 0x0c
 314:	9d 85       	ldd	r25, Y+13	; 0x0d
 316:	81 30       	cpi	r24, 0x01	; 1
 318:	91 05       	cpc	r25, r1
 31a:	09 f4       	brne	.+2      	; 0x31e <MDIO_voidSetPinValue+0x30>
 31c:	4f c0       	rjmp	.+158    	; 0x3bc <MDIO_voidSetPinValue+0xce>
 31e:	2c 85       	ldd	r18, Y+12	; 0x0c
 320:	3d 85       	ldd	r19, Y+13	; 0x0d
 322:	22 30       	cpi	r18, 0x02	; 2
 324:	31 05       	cpc	r19, r1
 326:	2c f4       	brge	.+10     	; 0x332 <MDIO_voidSetPinValue+0x44>
 328:	8c 85       	ldd	r24, Y+12	; 0x0c
 32a:	9d 85       	ldd	r25, Y+13	; 0x0d
 32c:	00 97       	sbiw	r24, 0x00	; 0
 32e:	71 f0       	breq	.+28     	; 0x34c <MDIO_voidSetPinValue+0x5e>
 330:	eb c0       	rjmp	.+470    	; 0x508 <MDIO_voidSetPinValue+0x21a>
 332:	2c 85       	ldd	r18, Y+12	; 0x0c
 334:	3d 85       	ldd	r19, Y+13	; 0x0d
 336:	22 30       	cpi	r18, 0x02	; 2
 338:	31 05       	cpc	r19, r1
 33a:	09 f4       	brne	.+2      	; 0x33e <MDIO_voidSetPinValue+0x50>
 33c:	77 c0       	rjmp	.+238    	; 0x42c <MDIO_voidSetPinValue+0x13e>
 33e:	8c 85       	ldd	r24, Y+12	; 0x0c
 340:	9d 85       	ldd	r25, Y+13	; 0x0d
 342:	83 30       	cpi	r24, 0x03	; 3
 344:	91 05       	cpc	r25, r1
 346:	09 f4       	brne	.+2      	; 0x34a <MDIO_voidSetPinValue+0x5c>
 348:	a9 c0       	rjmp	.+338    	; 0x49c <MDIO_voidSetPinValue+0x1ae>
 34a:	de c0       	rjmp	.+444    	; 0x508 <MDIO_voidSetPinValue+0x21a>
		{
		case PORTA:
			switch(A_u8Value)
 34c:	8b 81       	ldd	r24, Y+3	; 0x03
 34e:	28 2f       	mov	r18, r24
 350:	30 e0       	ldi	r19, 0x00	; 0
 352:	3b 87       	std	Y+11, r19	; 0x0b
 354:	2a 87       	std	Y+10, r18	; 0x0a
 356:	8a 85       	ldd	r24, Y+10	; 0x0a
 358:	9b 85       	ldd	r25, Y+11	; 0x0b
 35a:	00 97       	sbiw	r24, 0x00	; 0
 35c:	d1 f0       	breq	.+52     	; 0x392 <MDIO_voidSetPinValue+0xa4>
 35e:	2a 85       	ldd	r18, Y+10	; 0x0a
 360:	3b 85       	ldd	r19, Y+11	; 0x0b
 362:	21 30       	cpi	r18, 0x01	; 1
 364:	31 05       	cpc	r19, r1
 366:	09 f0       	breq	.+2      	; 0x36a <MDIO_voidSetPinValue+0x7c>
 368:	cf c0       	rjmp	.+414    	; 0x508 <MDIO_voidSetPinValue+0x21a>
			{
			case PIN_HIGH: SET_BIT(PORTA_REG,A_u8PinId);
 36a:	ab e3       	ldi	r26, 0x3B	; 59
 36c:	b0 e0       	ldi	r27, 0x00	; 0
 36e:	eb e3       	ldi	r30, 0x3B	; 59
 370:	f0 e0       	ldi	r31, 0x00	; 0
 372:	80 81       	ld	r24, Z
 374:	48 2f       	mov	r20, r24
 376:	8a 81       	ldd	r24, Y+2	; 0x02
 378:	28 2f       	mov	r18, r24
 37a:	30 e0       	ldi	r19, 0x00	; 0
 37c:	81 e0       	ldi	r24, 0x01	; 1
 37e:	90 e0       	ldi	r25, 0x00	; 0
 380:	02 2e       	mov	r0, r18
 382:	02 c0       	rjmp	.+4      	; 0x388 <MDIO_voidSetPinValue+0x9a>
 384:	88 0f       	add	r24, r24
 386:	99 1f       	adc	r25, r25
 388:	0a 94       	dec	r0
 38a:	e2 f7       	brpl	.-8      	; 0x384 <MDIO_voidSetPinValue+0x96>
 38c:	84 2b       	or	r24, r20
 38e:	8c 93       	st	X, r24
 390:	bb c0       	rjmp	.+374    	; 0x508 <MDIO_voidSetPinValue+0x21a>
						   break;
			case PIN_LOW : CLR_BIT(PORTA_REG,A_u8PinId);
 392:	ab e3       	ldi	r26, 0x3B	; 59
 394:	b0 e0       	ldi	r27, 0x00	; 0
 396:	eb e3       	ldi	r30, 0x3B	; 59
 398:	f0 e0       	ldi	r31, 0x00	; 0
 39a:	80 81       	ld	r24, Z
 39c:	48 2f       	mov	r20, r24
 39e:	8a 81       	ldd	r24, Y+2	; 0x02
 3a0:	28 2f       	mov	r18, r24
 3a2:	30 e0       	ldi	r19, 0x00	; 0
 3a4:	81 e0       	ldi	r24, 0x01	; 1
 3a6:	90 e0       	ldi	r25, 0x00	; 0
 3a8:	02 2e       	mov	r0, r18
 3aa:	02 c0       	rjmp	.+4      	; 0x3b0 <MDIO_voidSetPinValue+0xc2>
 3ac:	88 0f       	add	r24, r24
 3ae:	99 1f       	adc	r25, r25
 3b0:	0a 94       	dec	r0
 3b2:	e2 f7       	brpl	.-8      	; 0x3ac <MDIO_voidSetPinValue+0xbe>
 3b4:	80 95       	com	r24
 3b6:	84 23       	and	r24, r20
 3b8:	8c 93       	st	X, r24
 3ba:	a6 c0       	rjmp	.+332    	; 0x508 <MDIO_voidSetPinValue+0x21a>
			default:
					 break;
			}
			break;
		case PORTB:
			switch(A_u8Value)
 3bc:	8b 81       	ldd	r24, Y+3	; 0x03
 3be:	28 2f       	mov	r18, r24
 3c0:	30 e0       	ldi	r19, 0x00	; 0
 3c2:	39 87       	std	Y+9, r19	; 0x09
 3c4:	28 87       	std	Y+8, r18	; 0x08
 3c6:	88 85       	ldd	r24, Y+8	; 0x08
 3c8:	99 85       	ldd	r25, Y+9	; 0x09
 3ca:	00 97       	sbiw	r24, 0x00	; 0
 3cc:	d1 f0       	breq	.+52     	; 0x402 <MDIO_voidSetPinValue+0x114>
 3ce:	28 85       	ldd	r18, Y+8	; 0x08
 3d0:	39 85       	ldd	r19, Y+9	; 0x09
 3d2:	21 30       	cpi	r18, 0x01	; 1
 3d4:	31 05       	cpc	r19, r1
 3d6:	09 f0       	breq	.+2      	; 0x3da <MDIO_voidSetPinValue+0xec>
 3d8:	97 c0       	rjmp	.+302    	; 0x508 <MDIO_voidSetPinValue+0x21a>
			{
			case PIN_HIGH: SET_BIT(PORTB_REG,A_u8PinId);
 3da:	a8 e3       	ldi	r26, 0x38	; 56
 3dc:	b0 e0       	ldi	r27, 0x00	; 0
 3de:	e8 e3       	ldi	r30, 0x38	; 56
 3e0:	f0 e0       	ldi	r31, 0x00	; 0
 3e2:	80 81       	ld	r24, Z
 3e4:	48 2f       	mov	r20, r24
 3e6:	8a 81       	ldd	r24, Y+2	; 0x02
 3e8:	28 2f       	mov	r18, r24
 3ea:	30 e0       	ldi	r19, 0x00	; 0
 3ec:	81 e0       	ldi	r24, 0x01	; 1
 3ee:	90 e0       	ldi	r25, 0x00	; 0
 3f0:	02 2e       	mov	r0, r18
 3f2:	02 c0       	rjmp	.+4      	; 0x3f8 <MDIO_voidSetPinValue+0x10a>
 3f4:	88 0f       	add	r24, r24
 3f6:	99 1f       	adc	r25, r25
 3f8:	0a 94       	dec	r0
 3fa:	e2 f7       	brpl	.-8      	; 0x3f4 <MDIO_voidSetPinValue+0x106>
 3fc:	84 2b       	or	r24, r20
 3fe:	8c 93       	st	X, r24
 400:	83 c0       	rjmp	.+262    	; 0x508 <MDIO_voidSetPinValue+0x21a>
					       break;
			case PIN_LOW : CLR_BIT(PORTB_REG,A_u8PinId);
 402:	a8 e3       	ldi	r26, 0x38	; 56
 404:	b0 e0       	ldi	r27, 0x00	; 0
 406:	e8 e3       	ldi	r30, 0x38	; 56
 408:	f0 e0       	ldi	r31, 0x00	; 0
 40a:	80 81       	ld	r24, Z
 40c:	48 2f       	mov	r20, r24
 40e:	8a 81       	ldd	r24, Y+2	; 0x02
 410:	28 2f       	mov	r18, r24
 412:	30 e0       	ldi	r19, 0x00	; 0
 414:	81 e0       	ldi	r24, 0x01	; 1
 416:	90 e0       	ldi	r25, 0x00	; 0
 418:	02 2e       	mov	r0, r18
 41a:	02 c0       	rjmp	.+4      	; 0x420 <MDIO_voidSetPinValue+0x132>
 41c:	88 0f       	add	r24, r24
 41e:	99 1f       	adc	r25, r25
 420:	0a 94       	dec	r0
 422:	e2 f7       	brpl	.-8      	; 0x41c <MDIO_voidSetPinValue+0x12e>
 424:	80 95       	com	r24
 426:	84 23       	and	r24, r20
 428:	8c 93       	st	X, r24
 42a:	6e c0       	rjmp	.+220    	; 0x508 <MDIO_voidSetPinValue+0x21a>
			default:
					break;
			}
			break;
		case PORTC:
			switch(A_u8Value)
 42c:	8b 81       	ldd	r24, Y+3	; 0x03
 42e:	28 2f       	mov	r18, r24
 430:	30 e0       	ldi	r19, 0x00	; 0
 432:	3f 83       	std	Y+7, r19	; 0x07
 434:	2e 83       	std	Y+6, r18	; 0x06
 436:	8e 81       	ldd	r24, Y+6	; 0x06
 438:	9f 81       	ldd	r25, Y+7	; 0x07
 43a:	00 97       	sbiw	r24, 0x00	; 0
 43c:	d1 f0       	breq	.+52     	; 0x472 <MDIO_voidSetPinValue+0x184>
 43e:	2e 81       	ldd	r18, Y+6	; 0x06
 440:	3f 81       	ldd	r19, Y+7	; 0x07
 442:	21 30       	cpi	r18, 0x01	; 1
 444:	31 05       	cpc	r19, r1
 446:	09 f0       	breq	.+2      	; 0x44a <MDIO_voidSetPinValue+0x15c>
 448:	5f c0       	rjmp	.+190    	; 0x508 <MDIO_voidSetPinValue+0x21a>
			{
			case PIN_HIGH: SET_BIT(PORTC_REG,A_u8PinId);
 44a:	a5 e3       	ldi	r26, 0x35	; 53
 44c:	b0 e0       	ldi	r27, 0x00	; 0
 44e:	e5 e3       	ldi	r30, 0x35	; 53
 450:	f0 e0       	ldi	r31, 0x00	; 0
 452:	80 81       	ld	r24, Z
 454:	48 2f       	mov	r20, r24
 456:	8a 81       	ldd	r24, Y+2	; 0x02
 458:	28 2f       	mov	r18, r24
 45a:	30 e0       	ldi	r19, 0x00	; 0
 45c:	81 e0       	ldi	r24, 0x01	; 1
 45e:	90 e0       	ldi	r25, 0x00	; 0
 460:	02 2e       	mov	r0, r18
 462:	02 c0       	rjmp	.+4      	; 0x468 <MDIO_voidSetPinValue+0x17a>
 464:	88 0f       	add	r24, r24
 466:	99 1f       	adc	r25, r25
 468:	0a 94       	dec	r0
 46a:	e2 f7       	brpl	.-8      	; 0x464 <MDIO_voidSetPinValue+0x176>
 46c:	84 2b       	or	r24, r20
 46e:	8c 93       	st	X, r24
 470:	4b c0       	rjmp	.+150    	; 0x508 <MDIO_voidSetPinValue+0x21a>
						   break;
			case PIN_LOW : CLR_BIT(PORTC_REG,A_u8PinId);
 472:	a5 e3       	ldi	r26, 0x35	; 53
 474:	b0 e0       	ldi	r27, 0x00	; 0
 476:	e5 e3       	ldi	r30, 0x35	; 53
 478:	f0 e0       	ldi	r31, 0x00	; 0
 47a:	80 81       	ld	r24, Z
 47c:	48 2f       	mov	r20, r24
 47e:	8a 81       	ldd	r24, Y+2	; 0x02
 480:	28 2f       	mov	r18, r24
 482:	30 e0       	ldi	r19, 0x00	; 0
 484:	81 e0       	ldi	r24, 0x01	; 1
 486:	90 e0       	ldi	r25, 0x00	; 0
 488:	02 2e       	mov	r0, r18
 48a:	02 c0       	rjmp	.+4      	; 0x490 <MDIO_voidSetPinValue+0x1a2>
 48c:	88 0f       	add	r24, r24
 48e:	99 1f       	adc	r25, r25
 490:	0a 94       	dec	r0
 492:	e2 f7       	brpl	.-8      	; 0x48c <MDIO_voidSetPinValue+0x19e>
 494:	80 95       	com	r24
 496:	84 23       	and	r24, r20
 498:	8c 93       	st	X, r24
 49a:	36 c0       	rjmp	.+108    	; 0x508 <MDIO_voidSetPinValue+0x21a>
			default:
					break;
			}
			break;
		case PORTD:
			switch(A_u8Value)
 49c:	8b 81       	ldd	r24, Y+3	; 0x03
 49e:	28 2f       	mov	r18, r24
 4a0:	30 e0       	ldi	r19, 0x00	; 0
 4a2:	3d 83       	std	Y+5, r19	; 0x05
 4a4:	2c 83       	std	Y+4, r18	; 0x04
 4a6:	8c 81       	ldd	r24, Y+4	; 0x04
 4a8:	9d 81       	ldd	r25, Y+5	; 0x05
 4aa:	00 97       	sbiw	r24, 0x00	; 0
 4ac:	c9 f0       	breq	.+50     	; 0x4e0 <MDIO_voidSetPinValue+0x1f2>
 4ae:	2c 81       	ldd	r18, Y+4	; 0x04
 4b0:	3d 81       	ldd	r19, Y+5	; 0x05
 4b2:	21 30       	cpi	r18, 0x01	; 1
 4b4:	31 05       	cpc	r19, r1
 4b6:	41 f5       	brne	.+80     	; 0x508 <MDIO_voidSetPinValue+0x21a>
			{
			case PIN_HIGH: SET_BIT(PORTD_REG,A_u8PinId);
 4b8:	a2 e3       	ldi	r26, 0x32	; 50
 4ba:	b0 e0       	ldi	r27, 0x00	; 0
 4bc:	e2 e3       	ldi	r30, 0x32	; 50
 4be:	f0 e0       	ldi	r31, 0x00	; 0
 4c0:	80 81       	ld	r24, Z
 4c2:	48 2f       	mov	r20, r24
 4c4:	8a 81       	ldd	r24, Y+2	; 0x02
 4c6:	28 2f       	mov	r18, r24
 4c8:	30 e0       	ldi	r19, 0x00	; 0
 4ca:	81 e0       	ldi	r24, 0x01	; 1
 4cc:	90 e0       	ldi	r25, 0x00	; 0
 4ce:	02 2e       	mov	r0, r18
 4d0:	02 c0       	rjmp	.+4      	; 0x4d6 <MDIO_voidSetPinValue+0x1e8>
 4d2:	88 0f       	add	r24, r24
 4d4:	99 1f       	adc	r25, r25
 4d6:	0a 94       	dec	r0
 4d8:	e2 f7       	brpl	.-8      	; 0x4d2 <MDIO_voidSetPinValue+0x1e4>
 4da:	84 2b       	or	r24, r20
 4dc:	8c 93       	st	X, r24
 4de:	14 c0       	rjmp	.+40     	; 0x508 <MDIO_voidSetPinValue+0x21a>
							 break;
			case PIN_LOW : CLR_BIT(PORTD_REG,A_u8PinId);
 4e0:	a2 e3       	ldi	r26, 0x32	; 50
 4e2:	b0 e0       	ldi	r27, 0x00	; 0
 4e4:	e2 e3       	ldi	r30, 0x32	; 50
 4e6:	f0 e0       	ldi	r31, 0x00	; 0
 4e8:	80 81       	ld	r24, Z
 4ea:	48 2f       	mov	r20, r24
 4ec:	8a 81       	ldd	r24, Y+2	; 0x02
 4ee:	28 2f       	mov	r18, r24
 4f0:	30 e0       	ldi	r19, 0x00	; 0
 4f2:	81 e0       	ldi	r24, 0x01	; 1
 4f4:	90 e0       	ldi	r25, 0x00	; 0
 4f6:	02 2e       	mov	r0, r18
 4f8:	02 c0       	rjmp	.+4      	; 0x4fe <MDIO_voidSetPinValue+0x210>
 4fa:	88 0f       	add	r24, r24
 4fc:	99 1f       	adc	r25, r25
 4fe:	0a 94       	dec	r0
 500:	e2 f7       	brpl	.-8      	; 0x4fa <MDIO_voidSetPinValue+0x20c>
 502:	80 95       	com	r24
 504:	84 23       	and	r24, r20
 506:	8c 93       	st	X, r24
		default:
			break;
		}


}
 508:	2d 96       	adiw	r28, 0x0d	; 13
 50a:	0f b6       	in	r0, 0x3f	; 63
 50c:	f8 94       	cli
 50e:	de bf       	out	0x3e, r29	; 62
 510:	0f be       	out	0x3f, r0	; 63
 512:	cd bf       	out	0x3d, r28	; 61
 514:	cf 91       	pop	r28
 516:	df 91       	pop	r29
 518:	08 95       	ret

0000051a <MDIO_u8GetPinValue>:

// PORT ID :- POTRTA - PORTB - PORTC - PORTD
// PIN ID :- PIN0 ... PIN7
u8 MDIO_u8GetPinValue(u8 A_u8PortId, u8 A_u8PinId)
{
 51a:	df 93       	push	r29
 51c:	cf 93       	push	r28
 51e:	00 d0       	rcall	.+0      	; 0x520 <MDIO_u8GetPinValue+0x6>
 520:	00 d0       	rcall	.+0      	; 0x522 <MDIO_u8GetPinValue+0x8>
 522:	0f 92       	push	r0
 524:	cd b7       	in	r28, 0x3d	; 61
 526:	de b7       	in	r29, 0x3e	; 62
 528:	8a 83       	std	Y+2, r24	; 0x02
 52a:	6b 83       	std	Y+3, r22	; 0x03
	u8 local_u8PinValue=0;
 52c:	19 82       	std	Y+1, r1	; 0x01
	switch(A_u8PortId)
 52e:	8a 81       	ldd	r24, Y+2	; 0x02
 530:	28 2f       	mov	r18, r24
 532:	30 e0       	ldi	r19, 0x00	; 0
 534:	3d 83       	std	Y+5, r19	; 0x05
 536:	2c 83       	std	Y+4, r18	; 0x04
 538:	4c 81       	ldd	r20, Y+4	; 0x04
 53a:	5d 81       	ldd	r21, Y+5	; 0x05
 53c:	41 30       	cpi	r20, 0x01	; 1
 53e:	51 05       	cpc	r21, r1
 540:	41 f1       	breq	.+80     	; 0x592 <MDIO_u8GetPinValue+0x78>
 542:	8c 81       	ldd	r24, Y+4	; 0x04
 544:	9d 81       	ldd	r25, Y+5	; 0x05
 546:	82 30       	cpi	r24, 0x02	; 2
 548:	91 05       	cpc	r25, r1
 54a:	34 f4       	brge	.+12     	; 0x558 <MDIO_u8GetPinValue+0x3e>
 54c:	2c 81       	ldd	r18, Y+4	; 0x04
 54e:	3d 81       	ldd	r19, Y+5	; 0x05
 550:	21 15       	cp	r18, r1
 552:	31 05       	cpc	r19, r1
 554:	61 f0       	breq	.+24     	; 0x56e <MDIO_u8GetPinValue+0x54>
 556:	52 c0       	rjmp	.+164    	; 0x5fc <MDIO_u8GetPinValue+0xe2>
 558:	4c 81       	ldd	r20, Y+4	; 0x04
 55a:	5d 81       	ldd	r21, Y+5	; 0x05
 55c:	42 30       	cpi	r20, 0x02	; 2
 55e:	51 05       	cpc	r21, r1
 560:	51 f1       	breq	.+84     	; 0x5b6 <MDIO_u8GetPinValue+0x9c>
 562:	8c 81       	ldd	r24, Y+4	; 0x04
 564:	9d 81       	ldd	r25, Y+5	; 0x05
 566:	83 30       	cpi	r24, 0x03	; 3
 568:	91 05       	cpc	r25, r1
 56a:	b9 f1       	breq	.+110    	; 0x5da <MDIO_u8GetPinValue+0xc0>
 56c:	47 c0       	rjmp	.+142    	; 0x5fc <MDIO_u8GetPinValue+0xe2>
	{
	case PORTA: local_u8PinValue = GET_BIT(PINA_REG,A_u8PinId);
 56e:	e9 e3       	ldi	r30, 0x39	; 57
 570:	f0 e0       	ldi	r31, 0x00	; 0
 572:	80 81       	ld	r24, Z
 574:	28 2f       	mov	r18, r24
 576:	30 e0       	ldi	r19, 0x00	; 0
 578:	8b 81       	ldd	r24, Y+3	; 0x03
 57a:	88 2f       	mov	r24, r24
 57c:	90 e0       	ldi	r25, 0x00	; 0
 57e:	a9 01       	movw	r20, r18
 580:	02 c0       	rjmp	.+4      	; 0x586 <MDIO_u8GetPinValue+0x6c>
 582:	55 95       	asr	r21
 584:	47 95       	ror	r20
 586:	8a 95       	dec	r24
 588:	e2 f7       	brpl	.-8      	; 0x582 <MDIO_u8GetPinValue+0x68>
 58a:	ca 01       	movw	r24, r20
 58c:	81 70       	andi	r24, 0x01	; 1
 58e:	89 83       	std	Y+1, r24	; 0x01
 590:	35 c0       	rjmp	.+106    	; 0x5fc <MDIO_u8GetPinValue+0xe2>
				break;
	case PORTB: local_u8PinValue = GET_BIT(PINB_REG,A_u8PinId);
 592:	e6 e3       	ldi	r30, 0x36	; 54
 594:	f0 e0       	ldi	r31, 0x00	; 0
 596:	80 81       	ld	r24, Z
 598:	28 2f       	mov	r18, r24
 59a:	30 e0       	ldi	r19, 0x00	; 0
 59c:	8b 81       	ldd	r24, Y+3	; 0x03
 59e:	88 2f       	mov	r24, r24
 5a0:	90 e0       	ldi	r25, 0x00	; 0
 5a2:	a9 01       	movw	r20, r18
 5a4:	02 c0       	rjmp	.+4      	; 0x5aa <MDIO_u8GetPinValue+0x90>
 5a6:	55 95       	asr	r21
 5a8:	47 95       	ror	r20
 5aa:	8a 95       	dec	r24
 5ac:	e2 f7       	brpl	.-8      	; 0x5a6 <MDIO_u8GetPinValue+0x8c>
 5ae:	ca 01       	movw	r24, r20
 5b0:	81 70       	andi	r24, 0x01	; 1
 5b2:	89 83       	std	Y+1, r24	; 0x01
 5b4:	23 c0       	rjmp	.+70     	; 0x5fc <MDIO_u8GetPinValue+0xe2>
				break;
	case PORTC: local_u8PinValue = GET_BIT(PINC_REG,A_u8PinId);
 5b6:	e3 e3       	ldi	r30, 0x33	; 51
 5b8:	f0 e0       	ldi	r31, 0x00	; 0
 5ba:	80 81       	ld	r24, Z
 5bc:	28 2f       	mov	r18, r24
 5be:	30 e0       	ldi	r19, 0x00	; 0
 5c0:	8b 81       	ldd	r24, Y+3	; 0x03
 5c2:	88 2f       	mov	r24, r24
 5c4:	90 e0       	ldi	r25, 0x00	; 0
 5c6:	a9 01       	movw	r20, r18
 5c8:	02 c0       	rjmp	.+4      	; 0x5ce <MDIO_u8GetPinValue+0xb4>
 5ca:	55 95       	asr	r21
 5cc:	47 95       	ror	r20
 5ce:	8a 95       	dec	r24
 5d0:	e2 f7       	brpl	.-8      	; 0x5ca <MDIO_u8GetPinValue+0xb0>
 5d2:	ca 01       	movw	r24, r20
 5d4:	81 70       	andi	r24, 0x01	; 1
 5d6:	89 83       	std	Y+1, r24	; 0x01
 5d8:	11 c0       	rjmp	.+34     	; 0x5fc <MDIO_u8GetPinValue+0xe2>
				break;
	case PORTD: local_u8PinValue = GET_BIT(PIND_REG,A_u8PinId);
 5da:	e0 e3       	ldi	r30, 0x30	; 48
 5dc:	f0 e0       	ldi	r31, 0x00	; 0
 5de:	80 81       	ld	r24, Z
 5e0:	28 2f       	mov	r18, r24
 5e2:	30 e0       	ldi	r19, 0x00	; 0
 5e4:	8b 81       	ldd	r24, Y+3	; 0x03
 5e6:	88 2f       	mov	r24, r24
 5e8:	90 e0       	ldi	r25, 0x00	; 0
 5ea:	a9 01       	movw	r20, r18
 5ec:	02 c0       	rjmp	.+4      	; 0x5f2 <MDIO_u8GetPinValue+0xd8>
 5ee:	55 95       	asr	r21
 5f0:	47 95       	ror	r20
 5f2:	8a 95       	dec	r24
 5f4:	e2 f7       	brpl	.-8      	; 0x5ee <MDIO_u8GetPinValue+0xd4>
 5f6:	ca 01       	movw	r24, r20
 5f8:	81 70       	andi	r24, 0x01	; 1
 5fa:	89 83       	std	Y+1, r24	; 0x01
				break;
	default:	break;
	}
	return local_u8PinValue;
 5fc:	89 81       	ldd	r24, Y+1	; 0x01
}
 5fe:	0f 90       	pop	r0
 600:	0f 90       	pop	r0
 602:	0f 90       	pop	r0
 604:	0f 90       	pop	r0
 606:	0f 90       	pop	r0
 608:	cf 91       	pop	r28
 60a:	df 91       	pop	r29
 60c:	08 95       	ret

0000060e <MDIO_voidSetPortValue>:
// PORT ID :- POTRTA - PORTB - PORTC - PORTD
// PORT VALUE:- PIN_LOW - PIN_HIGH
void MDIO_voidSetPortValue(u8 A_u8PortId, u8 A_u8Value)
{
 60e:	df 93       	push	r29
 610:	cf 93       	push	r28
 612:	00 d0       	rcall	.+0      	; 0x614 <MDIO_voidSetPortValue+0x6>
 614:	00 d0       	rcall	.+0      	; 0x616 <MDIO_voidSetPortValue+0x8>
 616:	cd b7       	in	r28, 0x3d	; 61
 618:	de b7       	in	r29, 0x3e	; 62
 61a:	89 83       	std	Y+1, r24	; 0x01
 61c:	6a 83       	std	Y+2, r22	; 0x02
	switch(A_u8PortId)
 61e:	89 81       	ldd	r24, Y+1	; 0x01
 620:	28 2f       	mov	r18, r24
 622:	30 e0       	ldi	r19, 0x00	; 0
 624:	3c 83       	std	Y+4, r19	; 0x04
 626:	2b 83       	std	Y+3, r18	; 0x03
 628:	8b 81       	ldd	r24, Y+3	; 0x03
 62a:	9c 81       	ldd	r25, Y+4	; 0x04
 62c:	81 30       	cpi	r24, 0x01	; 1
 62e:	91 05       	cpc	r25, r1
 630:	d1 f0       	breq	.+52     	; 0x666 <MDIO_voidSetPortValue+0x58>
 632:	2b 81       	ldd	r18, Y+3	; 0x03
 634:	3c 81       	ldd	r19, Y+4	; 0x04
 636:	22 30       	cpi	r18, 0x02	; 2
 638:	31 05       	cpc	r19, r1
 63a:	2c f4       	brge	.+10     	; 0x646 <MDIO_voidSetPortValue+0x38>
 63c:	8b 81       	ldd	r24, Y+3	; 0x03
 63e:	9c 81       	ldd	r25, Y+4	; 0x04
 640:	00 97       	sbiw	r24, 0x00	; 0
 642:	61 f0       	breq	.+24     	; 0x65c <MDIO_voidSetPortValue+0x4e>
 644:	1e c0       	rjmp	.+60     	; 0x682 <MDIO_voidSetPortValue+0x74>
 646:	2b 81       	ldd	r18, Y+3	; 0x03
 648:	3c 81       	ldd	r19, Y+4	; 0x04
 64a:	22 30       	cpi	r18, 0x02	; 2
 64c:	31 05       	cpc	r19, r1
 64e:	81 f0       	breq	.+32     	; 0x670 <MDIO_voidSetPortValue+0x62>
 650:	8b 81       	ldd	r24, Y+3	; 0x03
 652:	9c 81       	ldd	r25, Y+4	; 0x04
 654:	83 30       	cpi	r24, 0x03	; 3
 656:	91 05       	cpc	r25, r1
 658:	81 f0       	breq	.+32     	; 0x67a <MDIO_voidSetPortValue+0x6c>
 65a:	13 c0       	rjmp	.+38     	; 0x682 <MDIO_voidSetPortValue+0x74>
		{
		case PORTA: PORTA_REG =A_u8Value;
 65c:	eb e3       	ldi	r30, 0x3B	; 59
 65e:	f0 e0       	ldi	r31, 0x00	; 0
 660:	8a 81       	ldd	r24, Y+2	; 0x02
 662:	80 83       	st	Z, r24
 664:	0e c0       	rjmp	.+28     	; 0x682 <MDIO_voidSetPortValue+0x74>
					break;
		case PORTB: PORTB_REG =A_u8Value;
 666:	e8 e3       	ldi	r30, 0x38	; 56
 668:	f0 e0       	ldi	r31, 0x00	; 0
 66a:	8a 81       	ldd	r24, Y+2	; 0x02
 66c:	80 83       	st	Z, r24
 66e:	09 c0       	rjmp	.+18     	; 0x682 <MDIO_voidSetPortValue+0x74>
					break;
		case PORTC: PORTC_REG =A_u8Value;
 670:	e5 e3       	ldi	r30, 0x35	; 53
 672:	f0 e0       	ldi	r31, 0x00	; 0
 674:	8a 81       	ldd	r24, Y+2	; 0x02
 676:	80 83       	st	Z, r24
 678:	04 c0       	rjmp	.+8      	; 0x682 <MDIO_voidSetPortValue+0x74>
					break;
		case PORTD: PORTD_REG =A_u8Value;
 67a:	e2 e3       	ldi	r30, 0x32	; 50
 67c:	f0 e0       	ldi	r31, 0x00	; 0
 67e:	8a 81       	ldd	r24, Y+2	; 0x02
 680:	80 83       	st	Z, r24
					break;
		default:	break;
		}
}
 682:	0f 90       	pop	r0
 684:	0f 90       	pop	r0
 686:	0f 90       	pop	r0
 688:	0f 90       	pop	r0
 68a:	cf 91       	pop	r28
 68c:	df 91       	pop	r29
 68e:	08 95       	ret

00000690 <MDIO_voidSetPortDirection>:
// PORT ID :- POTRTA - PORTB - PORTC - PORTD
// PORT DIRECTION:- PIN_INPUT - PIN_OUTPUT
void MDIO_voidSetPortDirection(u8 A_u8PortId, u8 A_u8Direction)
{
 690:	df 93       	push	r29
 692:	cf 93       	push	r28
 694:	00 d0       	rcall	.+0      	; 0x696 <MDIO_voidSetPortDirection+0x6>
 696:	00 d0       	rcall	.+0      	; 0x698 <MDIO_voidSetPortDirection+0x8>
 698:	cd b7       	in	r28, 0x3d	; 61
 69a:	de b7       	in	r29, 0x3e	; 62
 69c:	89 83       	std	Y+1, r24	; 0x01
 69e:	6a 83       	std	Y+2, r22	; 0x02
	switch(A_u8PortId)
 6a0:	89 81       	ldd	r24, Y+1	; 0x01
 6a2:	28 2f       	mov	r18, r24
 6a4:	30 e0       	ldi	r19, 0x00	; 0
 6a6:	3c 83       	std	Y+4, r19	; 0x04
 6a8:	2b 83       	std	Y+3, r18	; 0x03
 6aa:	8b 81       	ldd	r24, Y+3	; 0x03
 6ac:	9c 81       	ldd	r25, Y+4	; 0x04
 6ae:	81 30       	cpi	r24, 0x01	; 1
 6b0:	91 05       	cpc	r25, r1
 6b2:	d1 f0       	breq	.+52     	; 0x6e8 <MDIO_voidSetPortDirection+0x58>
 6b4:	2b 81       	ldd	r18, Y+3	; 0x03
 6b6:	3c 81       	ldd	r19, Y+4	; 0x04
 6b8:	22 30       	cpi	r18, 0x02	; 2
 6ba:	31 05       	cpc	r19, r1
 6bc:	2c f4       	brge	.+10     	; 0x6c8 <MDIO_voidSetPortDirection+0x38>
 6be:	8b 81       	ldd	r24, Y+3	; 0x03
 6c0:	9c 81       	ldd	r25, Y+4	; 0x04
 6c2:	00 97       	sbiw	r24, 0x00	; 0
 6c4:	61 f0       	breq	.+24     	; 0x6de <MDIO_voidSetPortDirection+0x4e>
 6c6:	1e c0       	rjmp	.+60     	; 0x704 <MDIO_voidSetPortDirection+0x74>
 6c8:	2b 81       	ldd	r18, Y+3	; 0x03
 6ca:	3c 81       	ldd	r19, Y+4	; 0x04
 6cc:	22 30       	cpi	r18, 0x02	; 2
 6ce:	31 05       	cpc	r19, r1
 6d0:	81 f0       	breq	.+32     	; 0x6f2 <MDIO_voidSetPortDirection+0x62>
 6d2:	8b 81       	ldd	r24, Y+3	; 0x03
 6d4:	9c 81       	ldd	r25, Y+4	; 0x04
 6d6:	83 30       	cpi	r24, 0x03	; 3
 6d8:	91 05       	cpc	r25, r1
 6da:	81 f0       	breq	.+32     	; 0x6fc <MDIO_voidSetPortDirection+0x6c>
 6dc:	13 c0       	rjmp	.+38     	; 0x704 <MDIO_voidSetPortDirection+0x74>
		{
		case PORTA: DDRA_REG = A_u8Direction;
 6de:	ea e3       	ldi	r30, 0x3A	; 58
 6e0:	f0 e0       	ldi	r31, 0x00	; 0
 6e2:	8a 81       	ldd	r24, Y+2	; 0x02
 6e4:	80 83       	st	Z, r24
 6e6:	0e c0       	rjmp	.+28     	; 0x704 <MDIO_voidSetPortDirection+0x74>
					break;
		case PORTB: DDRB_REG = A_u8Direction;
 6e8:	e7 e3       	ldi	r30, 0x37	; 55
 6ea:	f0 e0       	ldi	r31, 0x00	; 0
 6ec:	8a 81       	ldd	r24, Y+2	; 0x02
 6ee:	80 83       	st	Z, r24
 6f0:	09 c0       	rjmp	.+18     	; 0x704 <MDIO_voidSetPortDirection+0x74>
					break;
		case PORTC: DDRC_REG = A_u8Direction;
 6f2:	e4 e3       	ldi	r30, 0x34	; 52
 6f4:	f0 e0       	ldi	r31, 0x00	; 0
 6f6:	8a 81       	ldd	r24, Y+2	; 0x02
 6f8:	80 83       	st	Z, r24
 6fa:	04 c0       	rjmp	.+8      	; 0x704 <MDIO_voidSetPortDirection+0x74>
					break;
		case PORTD: DDRD_REG = A_u8Direction;
 6fc:	e1 e3       	ldi	r30, 0x31	; 49
 6fe:	f0 e0       	ldi	r31, 0x00	; 0
 700:	8a 81       	ldd	r24, Y+2	; 0x02
 702:	80 83       	st	Z, r24
					break;
		default:	break;
		}
}
 704:	0f 90       	pop	r0
 706:	0f 90       	pop	r0
 708:	0f 90       	pop	r0
 70a:	0f 90       	pop	r0
 70c:	cf 91       	pop	r28
 70e:	df 91       	pop	r29
 710:	08 95       	ret

00000712 <MGI_voidEnable>:
#include "../include/MCAL/GI/GI_configuration.h"



void MGI_voidEnable(void)
{
 712:	df 93       	push	r29
 714:	cf 93       	push	r28
 716:	cd b7       	in	r28, 0x3d	; 61
 718:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG,GLOBAL_INTERRUPT_ENABLE_BIT);
 71a:	af e5       	ldi	r26, 0x5F	; 95
 71c:	b0 e0       	ldi	r27, 0x00	; 0
 71e:	ef e5       	ldi	r30, 0x5F	; 95
 720:	f0 e0       	ldi	r31, 0x00	; 0
 722:	80 81       	ld	r24, Z
 724:	80 68       	ori	r24, 0x80	; 128
 726:	8c 93       	st	X, r24
}
 728:	cf 91       	pop	r28
 72a:	df 91       	pop	r29
 72c:	08 95       	ret

0000072e <MGI_voidDisable>:
void MGI_voidDisable(void)
{
 72e:	df 93       	push	r29
 730:	cf 93       	push	r28
 732:	cd b7       	in	r28, 0x3d	; 61
 734:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,GLOBAL_INTERRUPT_ENABLE_BIT);
 736:	af e5       	ldi	r26, 0x5F	; 95
 738:	b0 e0       	ldi	r27, 0x00	; 0
 73a:	ef e5       	ldi	r30, 0x5F	; 95
 73c:	f0 e0       	ldi	r31, 0x00	; 0
 73e:	80 81       	ld	r24, Z
 740:	8f 77       	andi	r24, 0x7F	; 127
 742:	8c 93       	st	X, r24
}
 744:	cf 91       	pop	r28
 746:	df 91       	pop	r29
 748:	08 95       	ret

0000074a <SRTOS_voidInit>:

/********************************************************************************/
/*  THIS FUNCTION INITIALIZE TIMER0 CTC MODE & CALL THE SCHEDULER EACH 200(Ms)  */
/********************************************************************************/
void SRTOS_voidInit(void)
{
 74a:	df 93       	push	r29
 74c:	cf 93       	push	r28
 74e:	cd b7       	in	r28, 0x3d	; 61
 750:	de b7       	in	r29, 0x3e	; 62
	/* INIT TIMER0 CTC_MODE */
	MTIMER0_voidInit();
 752:	0e 94 bb 04 	call	0x976	; 0x976 <MTIMER0_voidInit>
	/* CALL THE SCHEDULER FUNCTION */
	MTIMER0_voidSetCallBackCTC(SRTOS_voidScheduler);
 756:	87 e2       	ldi	r24, 0x27	; 39
 758:	94 e0       	ldi	r25, 0x04	; 4
 75a:	0e 94 62 05 	call	0xac4	; 0xac4 <MTIMER0_voidSetCallBackCTC>
}
 75e:	cf 91       	pop	r28
 760:	df 91       	pop	r29
 762:	08 95       	ret

00000764 <SRTOS_voidInitArryFunctions>:

/*******************************************************************************/
/*  THIS FUNCTION SET THE ADDRESS OF FUNCTION OF THE TASK NULL FOR FIRST TIME  */
/*******************************************************************************/
void SRTOS_voidInitArryFunctions(void)
{
 764:	df 93       	push	r29
 766:	cf 93       	push	r28
 768:	0f 92       	push	r0
 76a:	cd b7       	in	r28, 0x3d	; 61
 76c:	de b7       	in	r29, 0x3e	; 62
	u8 local_u8Counter = 0;
 76e:	19 82       	std	Y+1, r1	; 0x01
 770:	12 c0       	rjmp	.+36     	; 0x796 <SRTOS_voidInitArryFunctions+0x32>
	/* SET ALL FUNCTION ADRESSES IN  TASKS TO NULL */
	for(;local_u8Counter>RTOS_MAX_NUMBER_OF_TASKS;local_u8Counter++)
	{
		RTOS_ArrOfTasks[local_u8Counter].ptr = NULL;
 772:	89 81       	ldd	r24, Y+1	; 0x01
 774:	28 2f       	mov	r18, r24
 776:	30 e0       	ldi	r19, 0x00	; 0
 778:	c9 01       	movw	r24, r18
 77a:	88 0f       	add	r24, r24
 77c:	99 1f       	adc	r25, r25
 77e:	82 0f       	add	r24, r18
 780:	93 1f       	adc	r25, r19
 782:	88 0f       	add	r24, r24
 784:	99 1f       	adc	r25, r25
 786:	fc 01       	movw	r30, r24
 788:	e4 59       	subi	r30, 0x94	; 148
 78a:	ff 4f       	sbci	r31, 0xFF	; 255
 78c:	11 82       	std	Z+1, r1	; 0x01
 78e:	10 82       	st	Z, r1
/*******************************************************************************/
void SRTOS_voidInitArryFunctions(void)
{
	u8 local_u8Counter = 0;
	/* SET ALL FUNCTION ADRESSES IN  TASKS TO NULL */
	for(;local_u8Counter>RTOS_MAX_NUMBER_OF_TASKS;local_u8Counter++)
 790:	89 81       	ldd	r24, Y+1	; 0x01
 792:	8f 5f       	subi	r24, 0xFF	; 255
 794:	89 83       	std	Y+1, r24	; 0x01
 796:	89 81       	ldd	r24, Y+1	; 0x01
 798:	84 30       	cpi	r24, 0x04	; 4
 79a:	58 f7       	brcc	.-42     	; 0x772 <SRTOS_voidInitArryFunctions+0xe>
	{
		RTOS_ArrOfTasks[local_u8Counter].ptr = NULL;
	}
}
 79c:	0f 90       	pop	r0
 79e:	cf 91       	pop	r28
 7a0:	df 91       	pop	r29
 7a2:	08 95       	ret

000007a4 <SRTOS_voidCreatTask>:
/* 	(Periodicity) --> 1(ms)..2(ms)...							*/
/* 	(FirtsDelay) --> commonly = Periodicity -1					*/
/*	(PtrToFunc) --> THE ADDRESS OF THE FUNCTION FOR THE TASK	*/
/****************************************************************/
void SRTOS_voidCreatTask(u8 A_u8Periority, u16 A_u8Periodicity, u16 A_u8FirtsDelay, void(*A_PtrToFunc)(void))
{
 7a4:	df 93       	push	r29
 7a6:	cf 93       	push	r28
 7a8:	cd b7       	in	r28, 0x3d	; 61
 7aa:	de b7       	in	r29, 0x3e	; 62
 7ac:	27 97       	sbiw	r28, 0x07	; 7
 7ae:	0f b6       	in	r0, 0x3f	; 63
 7b0:	f8 94       	cli
 7b2:	de bf       	out	0x3e, r29	; 62
 7b4:	0f be       	out	0x3f, r0	; 63
 7b6:	cd bf       	out	0x3d, r28	; 61
 7b8:	89 83       	std	Y+1, r24	; 0x01
 7ba:	7b 83       	std	Y+3, r23	; 0x03
 7bc:	6a 83       	std	Y+2, r22	; 0x02
 7be:	5d 83       	std	Y+5, r21	; 0x05
 7c0:	4c 83       	std	Y+4, r20	; 0x04
 7c2:	3f 83       	std	Y+7, r19	; 0x07
 7c4:	2e 83       	std	Y+6, r18	; 0x06
	/*CHECK PERIORITY < NUM OF TASKS & PtrToFumc IS NOT NULL */
	if((A_u8Periority < RTOS_MAX_NUMBER_OF_TASKS) && (A_PtrToFunc != NULL))
 7c6:	89 81       	ldd	r24, Y+1	; 0x01
 7c8:	83 30       	cpi	r24, 0x03	; 3
 7ca:	c0 f5       	brcc	.+112    	; 0x83c <SRTOS_voidCreatTask+0x98>
 7cc:	8e 81       	ldd	r24, Y+6	; 0x06
 7ce:	9f 81       	ldd	r25, Y+7	; 0x07
 7d0:	00 97       	sbiw	r24, 0x00	; 0
 7d2:	a1 f1       	breq	.+104    	; 0x83c <SRTOS_voidCreatTask+0x98>
	{
		/** SAVE THE DATA IN TASK_TCB(STRUCT) **/
		/* SAVE FIRST DELAY VALUE */
		RTOS_ArrOfTasks[A_u8Periority].FirstDelay = A_u8FirtsDelay;
 7d4:	89 81       	ldd	r24, Y+1	; 0x01
 7d6:	28 2f       	mov	r18, r24
 7d8:	30 e0       	ldi	r19, 0x00	; 0
 7da:	c9 01       	movw	r24, r18
 7dc:	88 0f       	add	r24, r24
 7de:	99 1f       	adc	r25, r25
 7e0:	82 0f       	add	r24, r18
 7e2:	93 1f       	adc	r25, r19
 7e4:	88 0f       	add	r24, r24
 7e6:	99 1f       	adc	r25, r25
 7e8:	fc 01       	movw	r30, r24
 7ea:	e8 59       	subi	r30, 0x98	; 152
 7ec:	ff 4f       	sbci	r31, 0xFF	; 255
 7ee:	8c 81       	ldd	r24, Y+4	; 0x04
 7f0:	9d 81       	ldd	r25, Y+5	; 0x05
 7f2:	91 83       	std	Z+1, r25	; 0x01
 7f4:	80 83       	st	Z, r24
		/* SAVE PERIODICITY VALUE */
		RTOS_ArrOfTasks[A_u8Periority].Periodicity = A_u8Periodicity;
 7f6:	89 81       	ldd	r24, Y+1	; 0x01
 7f8:	28 2f       	mov	r18, r24
 7fa:	30 e0       	ldi	r19, 0x00	; 0
 7fc:	c9 01       	movw	r24, r18
 7fe:	88 0f       	add	r24, r24
 800:	99 1f       	adc	r25, r25
 802:	82 0f       	add	r24, r18
 804:	93 1f       	adc	r25, r19
 806:	01 96       	adiw	r24, 0x01	; 1
 808:	88 0f       	add	r24, r24
 80a:	99 1f       	adc	r25, r25
 80c:	fc 01       	movw	r30, r24
 80e:	e8 59       	subi	r30, 0x98	; 152
 810:	ff 4f       	sbci	r31, 0xFF	; 255
 812:	8a 81       	ldd	r24, Y+2	; 0x02
 814:	9b 81       	ldd	r25, Y+3	; 0x03
 816:	91 83       	std	Z+1, r25	; 0x01
 818:	80 83       	st	Z, r24
		/* SAVE FUNCTION ADDRESS */
		RTOS_ArrOfTasks[A_u8Periority].ptr = A_PtrToFunc;
 81a:	89 81       	ldd	r24, Y+1	; 0x01
 81c:	28 2f       	mov	r18, r24
 81e:	30 e0       	ldi	r19, 0x00	; 0
 820:	c9 01       	movw	r24, r18
 822:	88 0f       	add	r24, r24
 824:	99 1f       	adc	r25, r25
 826:	82 0f       	add	r24, r18
 828:	93 1f       	adc	r25, r19
 82a:	88 0f       	add	r24, r24
 82c:	99 1f       	adc	r25, r25
 82e:	fc 01       	movw	r30, r24
 830:	e4 59       	subi	r30, 0x94	; 148
 832:	ff 4f       	sbci	r31, 0xFF	; 255
 834:	8e 81       	ldd	r24, Y+6	; 0x06
 836:	9f 81       	ldd	r25, Y+7	; 0x07
 838:	91 83       	std	Z+1, r25	; 0x01
 83a:	80 83       	st	Z, r24

	}
}
 83c:	27 96       	adiw	r28, 0x07	; 7
 83e:	0f b6       	in	r0, 0x3f	; 63
 840:	f8 94       	cli
 842:	de bf       	out	0x3e, r29	; 62
 844:	0f be       	out	0x3f, r0	; 63
 846:	cd bf       	out	0x3d, r28	; 61
 848:	cf 91       	pop	r28
 84a:	df 91       	pop	r29
 84c:	08 95       	ret

0000084e <SRTOS_voidScheduler>:

/***************************************************************/
/*  THIS FUNCTION IS REPEATED BY TIMER0 CTC MODE EACH 200(Ms)  */
/***************************************************************/
void SRTOS_voidScheduler(void)
{
 84e:	df 93       	push	r29
 850:	cf 93       	push	r28
 852:	0f 92       	push	r0
 854:	cd b7       	in	r28, 0x3d	; 61
 856:	de b7       	in	r29, 0x3e	; 62
	static u8 local_u8Counter = 0;
	local_u8Counter++;
 858:	80 91 60 00 	lds	r24, 0x0060
 85c:	8f 5f       	subi	r24, 0xFF	; 255
 85e:	80 93 60 00 	sts	0x0060, r24
	/* AFTER 1(ms) local_u8Counter = 5 */
	if (local_u8Counter == 5)
 862:	80 91 60 00 	lds	r24, 0x0060
 866:	85 30       	cpi	r24, 0x05	; 5
 868:	09 f0       	breq	.+2      	; 0x86c <__stack+0xd>
 86a:	81 c0       	rjmp	.+258    	; 0x96e <__stack+0x10f>
	{
		local_u8Counter = 0;
 86c:	10 92 60 00 	sts	0x0060, r1
		u8 local_u8TaskCounter = 0;
 870:	19 82       	std	Y+1, r1	; 0x01
 872:	79 c0       	rjmp	.+242    	; 0x966 <__stack+0x107>
		for(;local_u8TaskCounter<RTOS_MAX_NUMBER_OF_TASKS;local_u8TaskCounter++)
		{
			/** CHECK THE TASK IS READY **/
			/* IF FIRST DELAY IS ZERO */
			if(RTOS_ArrOfTasks[local_u8TaskCounter].FirstDelay == 0 )
 874:	89 81       	ldd	r24, Y+1	; 0x01
 876:	28 2f       	mov	r18, r24
 878:	30 e0       	ldi	r19, 0x00	; 0
 87a:	c9 01       	movw	r24, r18
 87c:	88 0f       	add	r24, r24
 87e:	99 1f       	adc	r25, r25
 880:	82 0f       	add	r24, r18
 882:	93 1f       	adc	r25, r19
 884:	88 0f       	add	r24, r24
 886:	99 1f       	adc	r25, r25
 888:	fc 01       	movw	r30, r24
 88a:	e8 59       	subi	r30, 0x98	; 152
 88c:	ff 4f       	sbci	r31, 0xFF	; 255
 88e:	80 81       	ld	r24, Z
 890:	91 81       	ldd	r25, Z+1	; 0x01
 892:	00 97       	sbiw	r24, 0x00	; 0
 894:	09 f0       	breq	.+2      	; 0x898 <__stack+0x39>
 896:	46 c0       	rjmp	.+140    	; 0x924 <__stack+0xc5>
			{
				/* IF THE FUNCTION EXIST */
				if(RTOS_ArrOfTasks[local_u8TaskCounter].ptr != NULL)
 898:	89 81       	ldd	r24, Y+1	; 0x01
 89a:	28 2f       	mov	r18, r24
 89c:	30 e0       	ldi	r19, 0x00	; 0
 89e:	c9 01       	movw	r24, r18
 8a0:	88 0f       	add	r24, r24
 8a2:	99 1f       	adc	r25, r25
 8a4:	82 0f       	add	r24, r18
 8a6:	93 1f       	adc	r25, r19
 8a8:	88 0f       	add	r24, r24
 8aa:	99 1f       	adc	r25, r25
 8ac:	fc 01       	movw	r30, r24
 8ae:	e4 59       	subi	r30, 0x94	; 148
 8b0:	ff 4f       	sbci	r31, 0xFF	; 255
 8b2:	80 81       	ld	r24, Z
 8b4:	91 81       	ldd	r25, Z+1	; 0x01
 8b6:	00 97       	sbiw	r24, 0x00	; 0
 8b8:	09 f4       	brne	.+2      	; 0x8bc <__stack+0x5d>
 8ba:	52 c0       	rjmp	.+164    	; 0x960 <__stack+0x101>
				{
					/* CALL THE FUNCTION OF TASK */
					RTOS_ArrOfTasks[local_u8TaskCounter].ptr();
 8bc:	89 81       	ldd	r24, Y+1	; 0x01
 8be:	28 2f       	mov	r18, r24
 8c0:	30 e0       	ldi	r19, 0x00	; 0
 8c2:	c9 01       	movw	r24, r18
 8c4:	88 0f       	add	r24, r24
 8c6:	99 1f       	adc	r25, r25
 8c8:	82 0f       	add	r24, r18
 8ca:	93 1f       	adc	r25, r19
 8cc:	88 0f       	add	r24, r24
 8ce:	99 1f       	adc	r25, r25
 8d0:	fc 01       	movw	r30, r24
 8d2:	e4 59       	subi	r30, 0x94	; 148
 8d4:	ff 4f       	sbci	r31, 0xFF	; 255
 8d6:	01 90       	ld	r0, Z+
 8d8:	f0 81       	ld	r31, Z
 8da:	e0 2d       	mov	r30, r0
 8dc:	09 95       	icall
					/* THEN MAKE THE FIRST DELAY(ms) = Periodicity (ms) - 1(ms) */
					RTOS_ArrOfTasks[local_u8TaskCounter].FirstDelay = RTOS_ArrOfTasks[local_u8TaskCounter].Periodicity - 1;
 8de:	89 81       	ldd	r24, Y+1	; 0x01
 8e0:	48 2f       	mov	r20, r24
 8e2:	50 e0       	ldi	r21, 0x00	; 0
 8e4:	89 81       	ldd	r24, Y+1	; 0x01
 8e6:	28 2f       	mov	r18, r24
 8e8:	30 e0       	ldi	r19, 0x00	; 0
 8ea:	c9 01       	movw	r24, r18
 8ec:	88 0f       	add	r24, r24
 8ee:	99 1f       	adc	r25, r25
 8f0:	82 0f       	add	r24, r18
 8f2:	93 1f       	adc	r25, r19
 8f4:	01 96       	adiw	r24, 0x01	; 1
 8f6:	88 0f       	add	r24, r24
 8f8:	99 1f       	adc	r25, r25
 8fa:	fc 01       	movw	r30, r24
 8fc:	e8 59       	subi	r30, 0x98	; 152
 8fe:	ff 4f       	sbci	r31, 0xFF	; 255
 900:	80 81       	ld	r24, Z
 902:	91 81       	ldd	r25, Z+1	; 0x01
 904:	9c 01       	movw	r18, r24
 906:	21 50       	subi	r18, 0x01	; 1
 908:	30 40       	sbci	r19, 0x00	; 0
 90a:	ca 01       	movw	r24, r20
 90c:	88 0f       	add	r24, r24
 90e:	99 1f       	adc	r25, r25
 910:	84 0f       	add	r24, r20
 912:	95 1f       	adc	r25, r21
 914:	88 0f       	add	r24, r24
 916:	99 1f       	adc	r25, r25
 918:	fc 01       	movw	r30, r24
 91a:	e8 59       	subi	r30, 0x98	; 152
 91c:	ff 4f       	sbci	r31, 0xFF	; 255
 91e:	31 83       	std	Z+1, r19	; 0x01
 920:	20 83       	st	Z, r18
 922:	1e c0       	rjmp	.+60     	; 0x960 <__stack+0x101>
				}
			}
			/* IF THE FIRST DELAY NOT ZARO */
			else
			{
				RTOS_ArrOfTasks[local_u8TaskCounter].FirstDelay--;
 924:	89 81       	ldd	r24, Y+1	; 0x01
 926:	28 2f       	mov	r18, r24
 928:	30 e0       	ldi	r19, 0x00	; 0
 92a:	c9 01       	movw	r24, r18
 92c:	88 0f       	add	r24, r24
 92e:	99 1f       	adc	r25, r25
 930:	82 0f       	add	r24, r18
 932:	93 1f       	adc	r25, r19
 934:	88 0f       	add	r24, r24
 936:	99 1f       	adc	r25, r25
 938:	fc 01       	movw	r30, r24
 93a:	e8 59       	subi	r30, 0x98	; 152
 93c:	ff 4f       	sbci	r31, 0xFF	; 255
 93e:	80 81       	ld	r24, Z
 940:	91 81       	ldd	r25, Z+1	; 0x01
 942:	ac 01       	movw	r20, r24
 944:	41 50       	subi	r20, 0x01	; 1
 946:	50 40       	sbci	r21, 0x00	; 0
 948:	c9 01       	movw	r24, r18
 94a:	88 0f       	add	r24, r24
 94c:	99 1f       	adc	r25, r25
 94e:	82 0f       	add	r24, r18
 950:	93 1f       	adc	r25, r19
 952:	88 0f       	add	r24, r24
 954:	99 1f       	adc	r25, r25
 956:	fc 01       	movw	r30, r24
 958:	e8 59       	subi	r30, 0x98	; 152
 95a:	ff 4f       	sbci	r31, 0xFF	; 255
 95c:	51 83       	std	Z+1, r21	; 0x01
 95e:	40 83       	st	Z, r20
	/* AFTER 1(ms) local_u8Counter = 5 */
	if (local_u8Counter == 5)
	{
		local_u8Counter = 0;
		u8 local_u8TaskCounter = 0;
		for(;local_u8TaskCounter<RTOS_MAX_NUMBER_OF_TASKS;local_u8TaskCounter++)
 960:	89 81       	ldd	r24, Y+1	; 0x01
 962:	8f 5f       	subi	r24, 0xFF	; 255
 964:	89 83       	std	Y+1, r24	; 0x01
 966:	89 81       	ldd	r24, Y+1	; 0x01
 968:	83 30       	cpi	r24, 0x03	; 3
 96a:	08 f4       	brcc	.+2      	; 0x96e <__stack+0x10f>
 96c:	83 cf       	rjmp	.-250    	; 0x874 <__stack+0x15>
			{
				RTOS_ArrOfTasks[local_u8TaskCounter].FirstDelay--;
			}
		}
	}
}
 96e:	0f 90       	pop	r0
 970:	cf 91       	pop	r28
 972:	df 91       	pop	r29
 974:	08 95       	ret

00000976 <MTIMER0_voidInit>:

/****************************************************/
/* 						TIMER0						*/
/****************************************************/
void MTIMER0_voidInit(void)
{
 976:	df 93       	push	r29
 978:	cf 93       	push	r28
 97a:	cd b7       	in	r28, 0x3d	; 61
 97c:	de b7       	in	r29, 0x3e	; 62

	#elif TIMER_MODE == PHASE_CORRECT_MODE

	#elif TIMER_MODE == CTC_MODE
		/* SET WAVE GENERATION MODE TO CTC_MODE */
		CLR_BIT(TCCR0,3);
 97e:	a3 e5       	ldi	r26, 0x53	; 83
 980:	b0 e0       	ldi	r27, 0x00	; 0
 982:	e3 e5       	ldi	r30, 0x53	; 83
 984:	f0 e0       	ldi	r31, 0x00	; 0
 986:	80 81       	ld	r24, Z
 988:	87 7f       	andi	r24, 0xF7	; 247
 98a:	8c 93       	st	X, r24
		SET_BIT(TCCR0,6);
 98c:	a3 e5       	ldi	r26, 0x53	; 83
 98e:	b0 e0       	ldi	r27, 0x00	; 0
 990:	e3 e5       	ldi	r30, 0x53	; 83
 992:	f0 e0       	ldi	r31, 0x00	; 0
 994:	80 81       	ld	r24, Z
 996:	80 64       	ori	r24, 0x40	; 64
 998:	8c 93       	st	X, r24
		/* TURN ON OVER-FLOW INTERRUPT */
		SET_BIT(TIMSK,1);
 99a:	a9 e5       	ldi	r26, 0x59	; 89
 99c:	b0 e0       	ldi	r27, 0x00	; 0
 99e:	e9 e5       	ldi	r30, 0x59	; 89
 9a0:	f0 e0       	ldi	r31, 0x00	; 0
 9a2:	80 81       	ld	r24, Z
 9a4:	82 60       	ori	r24, 0x02	; 2
 9a6:	8c 93       	st	X, r24
		/*SET ON COMPARE MATCH VALUE*/
		OCR0 = OCR0_VALUE;
 9a8:	ec e5       	ldi	r30, 0x5C	; 92
 9aa:	f0 e0       	ldi	r31, 0x00	; 0
 9ac:	87 ec       	ldi	r24, 0xC7	; 199
 9ae:	80 83       	st	Z, r24
		/* SET CLK (PRESCALER) & OC0 PIN ACTION */
		TCCR0 &= 0b11001000;
 9b0:	a3 e5       	ldi	r26, 0x53	; 83
 9b2:	b0 e0       	ldi	r27, 0x00	; 0
 9b4:	e3 e5       	ldi	r30, 0x53	; 83
 9b6:	f0 e0       	ldi	r31, 0x00	; 0
 9b8:	80 81       	ld	r24, Z
 9ba:	88 7c       	andi	r24, 0xC8	; 200
 9bc:	8c 93       	st	X, r24
		TCCR0 |= CLK_CONFIGURATION_TIMER0 | (CTC_OC0_PIN_ACTION << 4);
 9be:	a3 e5       	ldi	r26, 0x53	; 83
 9c0:	b0 e0       	ldi	r27, 0x00	; 0
 9c2:	e3 e5       	ldi	r30, 0x53	; 83
 9c4:	f0 e0       	ldi	r31, 0x00	; 0
 9c6:	80 81       	ld	r24, Z
 9c8:	82 60       	ori	r24, 0x02	; 2
 9ca:	8c 93       	st	X, r24
		TCCR0 |= CLK_CONFIGURATION_TIMER0 | (FAST_PWM_OC0_PIN_ACTION << 4);

	#else
			#error WRONG TIMER MODE CONFIGURATION
	#endif
}
 9cc:	cf 91       	pop	r28
 9ce:	df 91       	pop	r29
 9d0:	08 95       	ret

000009d2 <MTIMER0_voidStopTimer>:
void MTIMER0_voidStopTimer(void)
{
 9d2:	df 93       	push	r29
 9d4:	cf 93       	push	r28
 9d6:	cd b7       	in	r28, 0x3d	; 61
 9d8:	de b7       	in	r29, 0x3e	; 62
	/* STOP CLK */
	/*PRESCALER CLK*/
	TCCR0 &= 0b11111000;
 9da:	a3 e5       	ldi	r26, 0x53	; 83
 9dc:	b0 e0       	ldi	r27, 0x00	; 0
 9de:	e3 e5       	ldi	r30, 0x53	; 83
 9e0:	f0 e0       	ldi	r31, 0x00	; 0
 9e2:	80 81       	ld	r24, Z
 9e4:	88 7f       	andi	r24, 0xF8	; 248
 9e6:	8c 93       	st	X, r24
	TCCR0 |= 0b000;
 9e8:	a3 e5       	ldi	r26, 0x53	; 83
 9ea:	b0 e0       	ldi	r27, 0x00	; 0
 9ec:	e3 e5       	ldi	r30, 0x53	; 83
 9ee:	f0 e0       	ldi	r31, 0x00	; 0
 9f0:	80 81       	ld	r24, Z
 9f2:	8c 93       	st	X, r24
}
 9f4:	cf 91       	pop	r28
 9f6:	df 91       	pop	r29
 9f8:	08 95       	ret

000009fa <MTIMER0_voidSetPreloadValue>:

void MTIMER0_voidSetPreloadValue(u8 A_u8PreloadValue)
{
 9fa:	df 93       	push	r29
 9fc:	cf 93       	push	r28
 9fe:	0f 92       	push	r0
 a00:	cd b7       	in	r28, 0x3d	; 61
 a02:	de b7       	in	r29, 0x3e	; 62
 a04:	89 83       	std	Y+1, r24	; 0x01
	TCNT0 = A_u8PreloadValue;
 a06:	e2 e5       	ldi	r30, 0x52	; 82
 a08:	f0 e0       	ldi	r31, 0x00	; 0
 a0a:	89 81       	ldd	r24, Y+1	; 0x01
 a0c:	80 83       	st	Z, r24
}
 a0e:	0f 90       	pop	r0
 a10:	cf 91       	pop	r28
 a12:	df 91       	pop	r29
 a14:	08 95       	ret

00000a16 <MTIMER0_voidSetOCR0Value>:
/*SET OCR0 VALUE ON REAL-TIME*/
void MTIMER0_voidSetOCR0Value(u8 A_u8OCR0Value)
{
 a16:	df 93       	push	r29
 a18:	cf 93       	push	r28
 a1a:	0f 92       	push	r0
 a1c:	cd b7       	in	r28, 0x3d	; 61
 a1e:	de b7       	in	r29, 0x3e	; 62
 a20:	89 83       	std	Y+1, r24	; 0x01
	OCR0 = A_u8OCR0Value;
 a22:	ec e5       	ldi	r30, 0x5C	; 92
 a24:	f0 e0       	ldi	r31, 0x00	; 0
 a26:	89 81       	ldd	r24, Y+1	; 0x01
 a28:	80 83       	st	Z, r24
}
 a2a:	0f 90       	pop	r0
 a2c:	cf 91       	pop	r28
 a2e:	df 91       	pop	r29
 a30:	08 95       	ret

00000a32 <MTIMER0_voidSetCallBackOVF>:

/* INTERRUPT NORMAL MODE */
void (*TIMER0_OVF_CallBack)(void) = NULL;

void MTIMER0_voidSetCallBackOVF(void (*PtrToFunction)(void))
{
 a32:	df 93       	push	r29
 a34:	cf 93       	push	r28
 a36:	00 d0       	rcall	.+0      	; 0xa38 <MTIMER0_voidSetCallBackOVF+0x6>
 a38:	cd b7       	in	r28, 0x3d	; 61
 a3a:	de b7       	in	r29, 0x3e	; 62
 a3c:	9a 83       	std	Y+2, r25	; 0x02
 a3e:	89 83       	std	Y+1, r24	; 0x01
	if(PtrToFunction != NULL)
 a40:	89 81       	ldd	r24, Y+1	; 0x01
 a42:	9a 81       	ldd	r25, Y+2	; 0x02
 a44:	00 97       	sbiw	r24, 0x00	; 0
 a46:	31 f0       	breq	.+12     	; 0xa54 <MTIMER0_voidSetCallBackOVF+0x22>
	{
	 TIMER0_OVF_CallBack = PtrToFunction;
 a48:	89 81       	ldd	r24, Y+1	; 0x01
 a4a:	9a 81       	ldd	r25, Y+2	; 0x02
 a4c:	90 93 62 00 	sts	0x0062, r25
 a50:	80 93 61 00 	sts	0x0061, r24
	}
}
 a54:	0f 90       	pop	r0
 a56:	0f 90       	pop	r0
 a58:	cf 91       	pop	r28
 a5a:	df 91       	pop	r29
 a5c:	08 95       	ret

00000a5e <__vector_11>:
void __vector_11(void)  __attribute__((signal));
void __vector_11(void)
{
 a5e:	1f 92       	push	r1
 a60:	0f 92       	push	r0
 a62:	0f b6       	in	r0, 0x3f	; 63
 a64:	0f 92       	push	r0
 a66:	11 24       	eor	r1, r1
 a68:	2f 93       	push	r18
 a6a:	3f 93       	push	r19
 a6c:	4f 93       	push	r20
 a6e:	5f 93       	push	r21
 a70:	6f 93       	push	r22
 a72:	7f 93       	push	r23
 a74:	8f 93       	push	r24
 a76:	9f 93       	push	r25
 a78:	af 93       	push	r26
 a7a:	bf 93       	push	r27
 a7c:	ef 93       	push	r30
 a7e:	ff 93       	push	r31
 a80:	df 93       	push	r29
 a82:	cf 93       	push	r28
 a84:	cd b7       	in	r28, 0x3d	; 61
 a86:	de b7       	in	r29, 0x3e	; 62
	if(TIMER0_OVF_CallBack != NULL)
 a88:	80 91 61 00 	lds	r24, 0x0061
 a8c:	90 91 62 00 	lds	r25, 0x0062
 a90:	00 97       	sbiw	r24, 0x00	; 0
 a92:	29 f0       	breq	.+10     	; 0xa9e <__vector_11+0x40>
	{
		TIMER0_OVF_CallBack();
 a94:	e0 91 61 00 	lds	r30, 0x0061
 a98:	f0 91 62 00 	lds	r31, 0x0062
 a9c:	09 95       	icall
	}
}
 a9e:	cf 91       	pop	r28
 aa0:	df 91       	pop	r29
 aa2:	ff 91       	pop	r31
 aa4:	ef 91       	pop	r30
 aa6:	bf 91       	pop	r27
 aa8:	af 91       	pop	r26
 aaa:	9f 91       	pop	r25
 aac:	8f 91       	pop	r24
 aae:	7f 91       	pop	r23
 ab0:	6f 91       	pop	r22
 ab2:	5f 91       	pop	r21
 ab4:	4f 91       	pop	r20
 ab6:	3f 91       	pop	r19
 ab8:	2f 91       	pop	r18
 aba:	0f 90       	pop	r0
 abc:	0f be       	out	0x3f, r0	; 63
 abe:	0f 90       	pop	r0
 ac0:	1f 90       	pop	r1
 ac2:	18 95       	reti

00000ac4 <MTIMER0_voidSetCallBackCTC>:

/* INTERRUPT CTC MODE */
void (*TIMER0_CTC_CallBack)(void) = NULL;

void MTIMER0_voidSetCallBackCTC(void (*PtrToFunction)(void))
{
 ac4:	df 93       	push	r29
 ac6:	cf 93       	push	r28
 ac8:	00 d0       	rcall	.+0      	; 0xaca <MTIMER0_voidSetCallBackCTC+0x6>
 aca:	cd b7       	in	r28, 0x3d	; 61
 acc:	de b7       	in	r29, 0x3e	; 62
 ace:	9a 83       	std	Y+2, r25	; 0x02
 ad0:	89 83       	std	Y+1, r24	; 0x01
	if(PtrToFunction != NULL)
 ad2:	89 81       	ldd	r24, Y+1	; 0x01
 ad4:	9a 81       	ldd	r25, Y+2	; 0x02
 ad6:	00 97       	sbiw	r24, 0x00	; 0
 ad8:	31 f0       	breq	.+12     	; 0xae6 <MTIMER0_voidSetCallBackCTC+0x22>
	{
	 TIMER0_CTC_CallBack = PtrToFunction;
 ada:	89 81       	ldd	r24, Y+1	; 0x01
 adc:	9a 81       	ldd	r25, Y+2	; 0x02
 ade:	90 93 64 00 	sts	0x0064, r25
 ae2:	80 93 63 00 	sts	0x0063, r24
	}
}
 ae6:	0f 90       	pop	r0
 ae8:	0f 90       	pop	r0
 aea:	cf 91       	pop	r28
 aec:	df 91       	pop	r29
 aee:	08 95       	ret

00000af0 <__vector_10>:
void __vector_10(void)  __attribute__((signal));
void __vector_10(void)
{
 af0:	1f 92       	push	r1
 af2:	0f 92       	push	r0
 af4:	0f b6       	in	r0, 0x3f	; 63
 af6:	0f 92       	push	r0
 af8:	11 24       	eor	r1, r1
 afa:	2f 93       	push	r18
 afc:	3f 93       	push	r19
 afe:	4f 93       	push	r20
 b00:	5f 93       	push	r21
 b02:	6f 93       	push	r22
 b04:	7f 93       	push	r23
 b06:	8f 93       	push	r24
 b08:	9f 93       	push	r25
 b0a:	af 93       	push	r26
 b0c:	bf 93       	push	r27
 b0e:	ef 93       	push	r30
 b10:	ff 93       	push	r31
 b12:	df 93       	push	r29
 b14:	cf 93       	push	r28
 b16:	cd b7       	in	r28, 0x3d	; 61
 b18:	de b7       	in	r29, 0x3e	; 62
	if(TIMER0_CTC_CallBack != NULL)
 b1a:	80 91 63 00 	lds	r24, 0x0063
 b1e:	90 91 64 00 	lds	r25, 0x0064
 b22:	00 97       	sbiw	r24, 0x00	; 0
 b24:	29 f0       	breq	.+10     	; 0xb30 <__vector_10+0x40>
	{
		TIMER0_CTC_CallBack();
 b26:	e0 91 63 00 	lds	r30, 0x0063
 b2a:	f0 91 64 00 	lds	r31, 0x0064
 b2e:	09 95       	icall
	}
}
 b30:	cf 91       	pop	r28
 b32:	df 91       	pop	r29
 b34:	ff 91       	pop	r31
 b36:	ef 91       	pop	r30
 b38:	bf 91       	pop	r27
 b3a:	af 91       	pop	r26
 b3c:	9f 91       	pop	r25
 b3e:	8f 91       	pop	r24
 b40:	7f 91       	pop	r23
 b42:	6f 91       	pop	r22
 b44:	5f 91       	pop	r21
 b46:	4f 91       	pop	r20
 b48:	3f 91       	pop	r19
 b4a:	2f 91       	pop	r18
 b4c:	0f 90       	pop	r0
 b4e:	0f be       	out	0x3f, r0	; 63
 b50:	0f 90       	pop	r0
 b52:	1f 90       	pop	r1
 b54:	18 95       	reti

00000b56 <MTIMER1_voidInit>:
/****************************************************/
/* 						TIMER1						*/
/****************************************************/
void MTIMER1_voidInit(void)
{
 b56:	df 93       	push	r29
 b58:	cf 93       	push	r28
 b5a:	cd b7       	in	r28, 0x3d	; 61
 b5c:	de b7       	in	r29, 0x3e	; 62
		/* SET CLK (PRESCALER)  */
		TCCR1B &= 0b10011000;
		TCCR1B |= CLK_CONFIGURATION_TIMER1 ;
	#elif TIMER1_MODE == FAST_PWM_ICR1
		/* SET WAVE GENERATION MODE TO NORMAL MODE */
		CLR_BIT(TCCR1A,0);
 b5e:	af e4       	ldi	r26, 0x4F	; 79
 b60:	b0 e0       	ldi	r27, 0x00	; 0
 b62:	ef e4       	ldi	r30, 0x4F	; 79
 b64:	f0 e0       	ldi	r31, 0x00	; 0
 b66:	80 81       	ld	r24, Z
 b68:	8e 7f       	andi	r24, 0xFE	; 254
 b6a:	8c 93       	st	X, r24
		SET_BIT(TCCR1A,1);
 b6c:	af e4       	ldi	r26, 0x4F	; 79
 b6e:	b0 e0       	ldi	r27, 0x00	; 0
 b70:	ef e4       	ldi	r30, 0x4F	; 79
 b72:	f0 e0       	ldi	r31, 0x00	; 0
 b74:	80 81       	ld	r24, Z
 b76:	82 60       	ori	r24, 0x02	; 2
 b78:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,3);
 b7a:	ae e4       	ldi	r26, 0x4E	; 78
 b7c:	b0 e0       	ldi	r27, 0x00	; 0
 b7e:	ee e4       	ldi	r30, 0x4E	; 78
 b80:	f0 e0       	ldi	r31, 0x00	; 0
 b82:	80 81       	ld	r24, Z
 b84:	88 60       	ori	r24, 0x08	; 8
 b86:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,4);
 b88:	ae e4       	ldi	r26, 0x4E	; 78
 b8a:	b0 e0       	ldi	r27, 0x00	; 0
 b8c:	ee e4       	ldi	r30, 0x4E	; 78
 b8e:	f0 e0       	ldi	r31, 0x00	; 0
 b90:	80 81       	ld	r24, Z
 b92:	80 61       	ori	r24, 0x10	; 16
 b94:	8c 93       	st	X, r24
		/* SET OC1A PIN ACTION */
		TCCR1A &= 0b10000011;
 b96:	af e4       	ldi	r26, 0x4F	; 79
 b98:	b0 e0       	ldi	r27, 0x00	; 0
 b9a:	ef e4       	ldi	r30, 0x4F	; 79
 b9c:	f0 e0       	ldi	r31, 0x00	; 0
 b9e:	80 81       	ld	r24, Z
 ba0:	83 78       	andi	r24, 0x83	; 131
 ba2:	8c 93       	st	X, r24
		TCCR1A |= (FAST_PWM_OC1A_PIN_ACTION << 6);
 ba4:	af e4       	ldi	r26, 0x4F	; 79
 ba6:	b0 e0       	ldi	r27, 0x00	; 0
 ba8:	ef e4       	ldi	r30, 0x4F	; 79
 baa:	f0 e0       	ldi	r31, 0x00	; 0
 bac:	80 81       	ld	r24, Z
 bae:	80 68       	ori	r24, 0x80	; 128
 bb0:	8c 93       	st	X, r24
		/*SET OC1B PIN ACTION*/
		TCCR1A |= (FAST_PWM_OC1B_PIN_ACTION << 4);
 bb2:	af e4       	ldi	r26, 0x4F	; 79
 bb4:	b0 e0       	ldi	r27, 0x00	; 0
 bb6:	ef e4       	ldi	r30, 0x4F	; 79
 bb8:	f0 e0       	ldi	r31, 0x00	; 0
 bba:	80 81       	ld	r24, Z
 bbc:	80 63       	ori	r24, 0x30	; 48
 bbe:	8c 93       	st	X, r24
		/*ICR1 VALUE*/
		ICR1 = ICR1_VALUE;
 bc0:	e6 e4       	ldi	r30, 0x46	; 70
 bc2:	f0 e0       	ldi	r31, 0x00	; 0
 bc4:	8f e1       	ldi	r24, 0x1F	; 31
 bc6:	9e e4       	ldi	r25, 0x4E	; 78
 bc8:	91 83       	std	Z+1, r25	; 0x01
 bca:	80 83       	st	Z, r24
		/* SET CLK (PRESCALER) */
		TCCR1B &= 0b10011000;
 bcc:	ae e4       	ldi	r26, 0x4E	; 78
 bce:	b0 e0       	ldi	r27, 0x00	; 0
 bd0:	ee e4       	ldi	r30, 0x4E	; 78
 bd2:	f0 e0       	ldi	r31, 0x00	; 0
 bd4:	80 81       	ld	r24, Z
 bd6:	88 79       	andi	r24, 0x98	; 152
 bd8:	8c 93       	st	X, r24
		TCCR1B |= CLK_CONFIGURATION_TIMER1 ;
 bda:	ae e4       	ldi	r26, 0x4E	; 78
 bdc:	b0 e0       	ldi	r27, 0x00	; 0
 bde:	ee e4       	ldi	r30, 0x4E	; 78
 be0:	f0 e0       	ldi	r31, 0x00	; 0
 be2:	80 81       	ld	r24, Z
 be4:	82 60       	ori	r24, 0x02	; 2
 be6:	8c 93       	st	X, r24
	#endif
}
 be8:	cf 91       	pop	r28
 bea:	df 91       	pop	r29
 bec:	08 95       	ret

00000bee <MTIMER1_voidSetOCR1AValue>:
/*SET OCR0 VALUE ON REAL-TIME*/
void MTIMER1_voidSetOCR1AValue(u16 A_u16OCR1AValue)
{
 bee:	df 93       	push	r29
 bf0:	cf 93       	push	r28
 bf2:	00 d0       	rcall	.+0      	; 0xbf4 <MTIMER1_voidSetOCR1AValue+0x6>
 bf4:	cd b7       	in	r28, 0x3d	; 61
 bf6:	de b7       	in	r29, 0x3e	; 62
 bf8:	9a 83       	std	Y+2, r25	; 0x02
 bfa:	89 83       	std	Y+1, r24	; 0x01
	OCR1A = A_u16OCR1AValue;
 bfc:	ea e4       	ldi	r30, 0x4A	; 74
 bfe:	f0 e0       	ldi	r31, 0x00	; 0
 c00:	89 81       	ldd	r24, Y+1	; 0x01
 c02:	9a 81       	ldd	r25, Y+2	; 0x02
 c04:	91 83       	std	Z+1, r25	; 0x01
 c06:	80 83       	st	Z, r24
}
 c08:	0f 90       	pop	r0
 c0a:	0f 90       	pop	r0
 c0c:	cf 91       	pop	r28
 c0e:	df 91       	pop	r29
 c10:	08 95       	ret

00000c12 <MTIMER1_voidSetOCR1BValue>:
void MTIMER1_voidSetOCR1BValue(u16 A_u16OCR1BValue)
{
 c12:	df 93       	push	r29
 c14:	cf 93       	push	r28
 c16:	00 d0       	rcall	.+0      	; 0xc18 <MTIMER1_voidSetOCR1BValue+0x6>
 c18:	cd b7       	in	r28, 0x3d	; 61
 c1a:	de b7       	in	r29, 0x3e	; 62
 c1c:	9a 83       	std	Y+2, r25	; 0x02
 c1e:	89 83       	std	Y+1, r24	; 0x01
	OCR1B = A_u16OCR1BValue;
 c20:	e8 e4       	ldi	r30, 0x48	; 72
 c22:	f0 e0       	ldi	r31, 0x00	; 0
 c24:	89 81       	ldd	r24, Y+1	; 0x01
 c26:	9a 81       	ldd	r25, Y+2	; 0x02
 c28:	91 83       	std	Z+1, r25	; 0x01
 c2a:	80 83       	st	Z, r24
}
 c2c:	0f 90       	pop	r0
 c2e:	0f 90       	pop	r0
 c30:	cf 91       	pop	r28
 c32:	df 91       	pop	r29
 c34:	08 95       	ret

00000c36 <MWDT_voidEnable>:

/****************************************************/
/* 					WATCH DOG TIMER					*/
/****************************************************/
void MWDT_voidEnable()
{
 c36:	df 93       	push	r29
 c38:	cf 93       	push	r28
 c3a:	cd b7       	in	r28, 0x3d	; 61
 c3c:	de b7       	in	r29, 0x3e	; 62
	/*SET WDE BIT & CLEAR WDTOE BIT*/
	SET_BIT(WDTCR,WDE);
 c3e:	a1 e4       	ldi	r26, 0x41	; 65
 c40:	b0 e0       	ldi	r27, 0x00	; 0
 c42:	e1 e4       	ldi	r30, 0x41	; 65
 c44:	f0 e0       	ldi	r31, 0x00	; 0
 c46:	80 81       	ld	r24, Z
 c48:	88 60       	ori	r24, 0x08	; 8
 c4a:	8c 93       	st	X, r24
	/*SET THE PRESCALER VALUE*/
	WDTCR |= WDT_PRESCALER_SLECT;
 c4c:	a1 e4       	ldi	r26, 0x41	; 65
 c4e:	b0 e0       	ldi	r27, 0x00	; 0
 c50:	e1 e4       	ldi	r30, 0x41	; 65
 c52:	f0 e0       	ldi	r31, 0x00	; 0
 c54:	80 81       	ld	r24, Z
 c56:	87 60       	ori	r24, 0x07	; 7
 c58:	8c 93       	st	X, r24
}
 c5a:	cf 91       	pop	r28
 c5c:	df 91       	pop	r29
 c5e:	08 95       	ret

00000c60 <MWDT_voidDisable>:
void MWDT_voidDisable()
{
 c60:	df 93       	push	r29
 c62:	cf 93       	push	r28
 c64:	cd b7       	in	r28, 0x3d	; 61
 c66:	de b7       	in	r29, 0x3e	; 62
	/*SET WDE BIT & SET WDTOE BIT*/
	SET_BIT(WDTCR,WDE);
 c68:	a1 e4       	ldi	r26, 0x41	; 65
 c6a:	b0 e0       	ldi	r27, 0x00	; 0
 c6c:	e1 e4       	ldi	r30, 0x41	; 65
 c6e:	f0 e0       	ldi	r31, 0x00	; 0
 c70:	80 81       	ld	r24, Z
 c72:	88 60       	ori	r24, 0x08	; 8
 c74:	8c 93       	st	X, r24
	SET_BIT(WDTCR,WDTOE);
 c76:	a1 e4       	ldi	r26, 0x41	; 65
 c78:	b0 e0       	ldi	r27, 0x00	; 0
 c7a:	e1 e4       	ldi	r30, 0x41	; 65
 c7c:	f0 e0       	ldi	r31, 0x00	; 0
 c7e:	80 81       	ld	r24, Z
 c80:	80 61       	ori	r24, 0x10	; 16
 c82:	8c 93       	st	X, r24
	WDTCR = 0x00;
 c84:	e1 e4       	ldi	r30, 0x41	; 65
 c86:	f0 e0       	ldi	r31, 0x00	; 0
 c88:	10 82       	st	Z, r1
}
 c8a:	cf 91       	pop	r28
 c8c:	df 91       	pop	r29
 c8e:	08 95       	ret

00000c90 <main>:
void Toggel_LED3(void);



void main(void)
{
 c90:	df 93       	push	r29
 c92:	cf 93       	push	r28
 c94:	cd b7       	in	r28, 0x3d	; 61
 c96:	de b7       	in	r29, 0x3e	; 62
	MDIO_voidInit();
 c98:	0e 94 3e 00 	call	0x7c	; 0x7c <MDIO_voidInit>
	MGI_voidEnable();
 c9c:	0e 94 89 03 	call	0x712	; 0x712 <MGI_voidEnable>

	SRTOS_voidInitArryFunctions();
 ca0:	0e 94 b2 03 	call	0x764	; 0x764 <SRTOS_voidInitArryFunctions>
	SRTOS_voidCreatTask(0,1000,0,Toggel_LED1);
 ca4:	20 e7       	ldi	r18, 0x70	; 112
 ca6:	36 e0       	ldi	r19, 0x06	; 6
 ca8:	80 e0       	ldi	r24, 0x00	; 0
 caa:	68 ee       	ldi	r22, 0xE8	; 232
 cac:	73 e0       	ldi	r23, 0x03	; 3
 cae:	40 e0       	ldi	r20, 0x00	; 0
 cb0:	50 e0       	ldi	r21, 0x00	; 0
 cb2:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <SRTOS_voidCreatTask>
	SRTOS_voidCreatTask(1,2000,0,Toggel_LED2);
 cb6:	2b e8       	ldi	r18, 0x8B	; 139
 cb8:	36 e0       	ldi	r19, 0x06	; 6
 cba:	81 e0       	ldi	r24, 0x01	; 1
 cbc:	60 ed       	ldi	r22, 0xD0	; 208
 cbe:	77 e0       	ldi	r23, 0x07	; 7
 cc0:	40 e0       	ldi	r20, 0x00	; 0
 cc2:	50 e0       	ldi	r21, 0x00	; 0
 cc4:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <SRTOS_voidCreatTask>
	SRTOS_voidCreatTask(2,3000,0,Toggel_LED3);
 cc8:	26 ea       	ldi	r18, 0xA6	; 166
 cca:	36 e0       	ldi	r19, 0x06	; 6
 ccc:	82 e0       	ldi	r24, 0x02	; 2
 cce:	68 eb       	ldi	r22, 0xB8	; 184
 cd0:	7b e0       	ldi	r23, 0x0B	; 11
 cd2:	40 e0       	ldi	r20, 0x00	; 0
 cd4:	50 e0       	ldi	r21, 0x00	; 0
 cd6:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <SRTOS_voidCreatTask>

	SRTOS_voidInit();
 cda:	0e 94 a5 03 	call	0x74a	; 0x74a <SRTOS_voidInit>
 cde:	ff cf       	rjmp	.-2      	; 0xcde <main+0x4e>

00000ce0 <Toggel_LED1>:
	}

}

void Toggel_LED1(void)
{
 ce0:	df 93       	push	r29
 ce2:	cf 93       	push	r28
 ce4:	cd b7       	in	r28, 0x3d	; 61
 ce6:	de b7       	in	r29, 0x3e	; 62
	static u8 local_u8Flag = 0;

	if(local_u8Flag == 0)
 ce8:	80 91 65 00 	lds	r24, 0x0065
 cec:	88 23       	and	r24, r24
 cee:	49 f4       	brne	.+18     	; 0xd02 <Toggel_LED1+0x22>
	{
		MDIO_voidSetPinValue(PORTA,PIN0,PIN_HIGH);
 cf0:	80 e0       	ldi	r24, 0x00	; 0
 cf2:	60 e0       	ldi	r22, 0x00	; 0
 cf4:	41 e0       	ldi	r20, 0x01	; 1
 cf6:	0e 94 77 01 	call	0x2ee	; 0x2ee <MDIO_voidSetPinValue>
		local_u8Flag = 1;
 cfa:	81 e0       	ldi	r24, 0x01	; 1
 cfc:	80 93 65 00 	sts	0x0065, r24
 d00:	07 c0       	rjmp	.+14     	; 0xd10 <Toggel_LED1+0x30>
	}
	else
	{
		MDIO_voidSetPinValue(PORTA,PIN0,PIN_LOW);
 d02:	80 e0       	ldi	r24, 0x00	; 0
 d04:	60 e0       	ldi	r22, 0x00	; 0
 d06:	40 e0       	ldi	r20, 0x00	; 0
 d08:	0e 94 77 01 	call	0x2ee	; 0x2ee <MDIO_voidSetPinValue>
		local_u8Flag = 0;
 d0c:	10 92 65 00 	sts	0x0065, r1
	}
}
 d10:	cf 91       	pop	r28
 d12:	df 91       	pop	r29
 d14:	08 95       	ret

00000d16 <Toggel_LED2>:
void Toggel_LED2(void)
{
 d16:	df 93       	push	r29
 d18:	cf 93       	push	r28
 d1a:	cd b7       	in	r28, 0x3d	; 61
 d1c:	de b7       	in	r29, 0x3e	; 62
	static u8 local_u8Flag = 0;

	if(local_u8Flag == 0)
 d1e:	80 91 66 00 	lds	r24, 0x0066
 d22:	88 23       	and	r24, r24
 d24:	49 f4       	brne	.+18     	; 0xd38 <Toggel_LED2+0x22>
	{
		MDIO_voidSetPinValue(PORTA,PIN1,PIN_HIGH);
 d26:	80 e0       	ldi	r24, 0x00	; 0
 d28:	61 e0       	ldi	r22, 0x01	; 1
 d2a:	41 e0       	ldi	r20, 0x01	; 1
 d2c:	0e 94 77 01 	call	0x2ee	; 0x2ee <MDIO_voidSetPinValue>
		local_u8Flag = 1;
 d30:	81 e0       	ldi	r24, 0x01	; 1
 d32:	80 93 66 00 	sts	0x0066, r24
 d36:	07 c0       	rjmp	.+14     	; 0xd46 <Toggel_LED2+0x30>
	}
	else
	{
		MDIO_voidSetPinValue(PORTA,PIN1,PIN_LOW);
 d38:	80 e0       	ldi	r24, 0x00	; 0
 d3a:	61 e0       	ldi	r22, 0x01	; 1
 d3c:	40 e0       	ldi	r20, 0x00	; 0
 d3e:	0e 94 77 01 	call	0x2ee	; 0x2ee <MDIO_voidSetPinValue>
		local_u8Flag = 0;
 d42:	10 92 66 00 	sts	0x0066, r1
	}
}
 d46:	cf 91       	pop	r28
 d48:	df 91       	pop	r29
 d4a:	08 95       	ret

00000d4c <Toggel_LED3>:
void Toggel_LED3(void)
{
 d4c:	df 93       	push	r29
 d4e:	cf 93       	push	r28
 d50:	cd b7       	in	r28, 0x3d	; 61
 d52:	de b7       	in	r29, 0x3e	; 62

	static u8 local_u8Flag = 0;

	if(local_u8Flag == 0)
 d54:	80 91 67 00 	lds	r24, 0x0067
 d58:	88 23       	and	r24, r24
 d5a:	49 f4       	brne	.+18     	; 0xd6e <Toggel_LED3+0x22>
	{
		MDIO_voidSetPinValue(PORTA,PIN2,PIN_HIGH);
 d5c:	80 e0       	ldi	r24, 0x00	; 0
 d5e:	62 e0       	ldi	r22, 0x02	; 2
 d60:	41 e0       	ldi	r20, 0x01	; 1
 d62:	0e 94 77 01 	call	0x2ee	; 0x2ee <MDIO_voidSetPinValue>
		local_u8Flag = 1;
 d66:	81 e0       	ldi	r24, 0x01	; 1
 d68:	80 93 67 00 	sts	0x0067, r24
 d6c:	07 c0       	rjmp	.+14     	; 0xd7c <Toggel_LED3+0x30>
	}
	else
	{
		MDIO_voidSetPinValue(PORTA,PIN2,PIN_LOW);
 d6e:	80 e0       	ldi	r24, 0x00	; 0
 d70:	62 e0       	ldi	r22, 0x02	; 2
 d72:	40 e0       	ldi	r20, 0x00	; 0
 d74:	0e 94 77 01 	call	0x2ee	; 0x2ee <MDIO_voidSetPinValue>
		local_u8Flag = 0;
 d78:	10 92 67 00 	sts	0x0067, r1
	}
}
 d7c:	cf 91       	pop	r28
 d7e:	df 91       	pop	r29
 d80:	08 95       	ret

00000d82 <_exit>:
 d82:	f8 94       	cli

00000d84 <__stop_program>:
 d84:	ff cf       	rjmp	.-2      	; 0xd84 <__stop_program>
